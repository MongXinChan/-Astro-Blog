<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MonX</title><description>罗德岛</description><link>https://loners.site/</link><language>zh_CN</language><item><title>Vue 3.0 快速上手教程</title><link>https://loners.site/posts/vue30/</link><guid isPermaLink="true">https://loners.site/posts/vue30/</guid><description>Vue 3 是 Vue.js 的最新版本，它带来了性能提升、更好的 TypeScript 支持以及新的 Composition API 等特性。本教程是基于 Vue 3 的快速上手教程，帮助你快速掌握其核心语法和功能。</description><pubDate>Wed, 26 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
本教程假设你已经具备基本的 JavaScript 和 HTML 知识。&lt;/p&gt;
&lt;p&gt;你可以通过 &lt;a href=&quot;https://v3.vuejs.org/guide/introduction.html&quot;&gt;Vue.js 官方文档&lt;/a&gt;了解更多关于 Vue 3 的详细信息。&lt;/p&gt;
&lt;p&gt;本笔记基于课程&lt;a href=&quot;https://www.bilibili.com/video/BV1Pg4y1A7pn&quot;&gt;半小时入门Vue3.0核心语法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;环境准备&lt;/h1&gt;
&lt;p&gt;在开始之前，确保你的开发环境已经安装了 Node.js 和 npm。你可以通过以下命令安装 Vue CLI：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，可以通过以下命令创建一个新的 Vue 3 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue create my-vue3-project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在创建过程中，确保选择 Vue 3 作为项目版本。&lt;/p&gt;
&lt;h1&gt;Vue 3 基础语法&lt;/h1&gt;
&lt;h2&gt;2.1 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Vue 3 引入了 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; 语法，它是一种更简洁的组件编写方式，适用于组合式 API。以下是一个简单的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- HelloWorld.vue --&amp;gt;
&amp;lt;script setup&amp;gt;
import { reactive, ref, computed, watch, watchEffect } from &apos;vue&apos;

// 定义响应式数据
const count = ref(0)
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

// 定义计算属性
const getLen = computed(() =&amp;gt; {
  console.log(&apos;INVOKE computed&apos;)
  return myData.friends.length
})

// 定义侦听器
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 定义自动侦听
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})

// 定义事件处理函数
function clickHandler() {
  count.value++
  myData.age++
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;greetings&quot;&amp;gt;
    &amp;lt;h1 class=&quot;green&quot;&amp;gt;{{ getLen }}&amp;lt;/h1&amp;gt;
    &amp;lt;button @click=&quot;clickHandler&quot;&amp;gt;增加&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
h1 {
  font-weight: 500;
  font-size: 2.6rem;
  position: relative;
  top: -10px;
}

button {
  margin-top: 20px;
  padding: 10px 20px;
  font-size: 16px;
}

.greetings h1,
.greetings h3 {
  text-align: center;
}

@media (min-width: 1024px) {
  .greetings h1,
  .greetings h3 {
    text-align: left;
  }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.2 响应式数据&lt;/h2&gt;
&lt;p&gt;Vue 3 使用 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;reactive&lt;/code&gt; 来定义响应式数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt; 用于定义基本数据类型的响应式数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reactive&lt;/code&gt; 用于定义对象类型的响应式数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, reactive } from &apos;vue&apos;

const count = ref(0) // 基本数据类型
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
}) // 对象类型
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3 计算属性&lt;/h2&gt;
&lt;p&gt;计算属性是基于依赖的缓存属性。当依赖的响应式数据发生变化时，计算属性会自动重新计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, computed } from &apos;vue&apos;

const content = ref(&apos;hello world&apos;)
const getLen = computed(() =&amp;gt; {
  return content.value.length
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.4 侦听器&lt;/h2&gt;
&lt;p&gt;侦听器用于监听数据的变化，并执行特定的操作。Vue 3 提供了 &lt;code&gt;watch&lt;/code&gt; 和 &lt;code&gt;watchEffect&lt;/code&gt; 两种侦听器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;watch&lt;/code&gt; 用于监听特定数据的变化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;watchEffect&lt;/code&gt; 用于自动侦听所有依赖的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, watch, watchEffect } from &apos;vue&apos;

const count = ref(0)
const myData = reactive({
  age: 21
})

// 监听特定数据的变化
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 自动侦听所有依赖的变化
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.5 浅响应式与只读数据&lt;/h2&gt;
&lt;p&gt;Vue 3 提供了 &lt;code&gt;shallowReactive&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 用于定义浅响应式数据和只读数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shallowReactive&lt;/code&gt; 用于定义浅响应式数据，只有外层数据是响应式的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly&lt;/code&gt; 用于定义只读数据，数据不能被修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { shallowReactive, readonly } from &apos;vue&apos;

const myData = shallowReactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

const myReadOnlyData = readonly({
  name: &apos;cmx&apos;,
  age: 21
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;组合式 API&lt;/h1&gt;
&lt;p&gt;组合式 API 是 Vue 3 的核心特性之一，它允许你将逻辑相关的代码组织在一起，提高代码的可维护性和可重用性。&lt;/p&gt;
&lt;h2&gt;3.1 使用 &lt;code&gt;setup&lt;/code&gt; 函数&lt;/h2&gt;
&lt;p&gt;在 Vue 3 中，&lt;code&gt;setup&lt;/code&gt; 函数是组合式 API 的入口点。你可以在 &lt;code&gt;setup&lt;/code&gt; 函数中定义响应式数据、生命周期钩子、计算属性等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { ref, computed } from &apos;vue&apos;

export default {
  setup() {
    const count = ref(0)
    const doubleCount = computed(() =&amp;gt; count.value * 2)

    return {
      count,
      doubleCount
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.2 自定义组合函数&lt;/h2&gt;
&lt;p&gt;自定义组合函数是一种将逻辑相关的代码封装在一起的方式，可以提高代码的可重用性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, computed } from &apos;vue&apos;

function useCounter() {
  const count = ref(0)
  const doubleCount = computed(() =&amp;gt; count.value * 2)
  const increment = () =&amp;gt; count.value++

  return { count, doubleCount, increment }
}

const { count, doubleCount, increment } = useCounter()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;TypeScript 支持&lt;/h1&gt;
&lt;p&gt;Vue 3 提供了更好的 TypeScript 支持，你可以通过定义类型来提高代码的可维护性和可读性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref } from &apos;vue&apos;

const count = ref&amp;lt;number&amp;gt;(0)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;示例代码&lt;/h1&gt;
&lt;p&gt;以下是完整的示例代码，展示了上述功能的综合应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- HelloWorld.vue --&amp;gt;
&amp;lt;script setup&amp;gt;
import { reactive, ref, computed, watch, watchEffect } from &apos;vue&apos;

// 定义响应式数据
const count = ref(0)
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

// 定义计算属性
const getLen = computed(() =&amp;gt; {
  console.log(&apos;INVOKE computed&apos;)
  return myData.friends.length
})

// 定义侦听器
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 定义自动侦听
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})

// 定义事件处理函数
function clickHandler() {
  count.value++
  myData.age++
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;greetings&quot;&amp;gt;
    &amp;lt;h1 class=&quot;green&quot;&amp;gt;{{ getLen }}&amp;lt;/h1&amp;gt;
    &amp;lt;button @click=&quot;clickHandler&quot;&amp;gt;增加&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
h1 {
  font-weight: 500;
  font-size: 2.6rem;
  position: relative;
  top: -10px;
}

button {
  margin-top: 20px;
  padding: 10px 20px;
  font-size: 16px;
}

.greetings h1,
.greetings h3 {
  text-align: center;
}

@media (min-width: 1024px) {
  .greetings h1,
  .greetings h3 {
    text-align: left;
  }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;通过以上内容，你已经掌握了 Vue 3 的基本语法和功能，包括 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;、响应式数据、计算属性、侦听器和组合式 API。这些功能将帮助你快速构建动态的用户界面。接下来，你可以通过阅读官方文档和实践更多项目，进一步提升你的 Vue.js 技能。&lt;/p&gt;
</content:encoded></item><item><title>Vue 2.0 快速上手教程</title><link>https://loners.site/posts/vue20/</link><guid isPermaLink="true">https://loners.site/posts/vue20/</guid><description>Vue.js 是一个用于构建用户界面的渐进式框架，它通过声明式的数据绑定和组件系统，简化了 DOM 操作和页面渲染。本教程将帮助你快速上手 Vue 2.0，并了解其基本概念和用法。</description><pubDate>Tue, 25 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;本教程假设你已经具备基本的 HTML、CSS 和 JavaScript 知识。如果你对这些知识不熟悉，可以先学习相关的教程。&lt;/p&gt;
&lt;p&gt;本笔记基于Bilibili课程&lt;a href=&quot;https://www.bilibili.com/video/BV1oj411D7jk&quot;&gt;30分钟学会Vue之核心语法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;环境准备&lt;/h1&gt;
&lt;p&gt;在开始之前，确保你的开发环境已经安装了 Node.js 和 npm。你可以通过以下命令安装 Vue CLI：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，可以通过以下命令创建一个新的 Vue 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue create my-vue-project
cd my-vue-project
npm run serve
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Vue 2.0 基础语法&lt;/h1&gt;
&lt;h2&gt;2.1 响应式数据与插值表达式&lt;/h2&gt;
&lt;p&gt;Vue 的核心特性之一是响应式数据绑定。通过在模板中使用插值表达式（&lt;code&gt;{{ }}&lt;/code&gt;），可以将数据动态绑定到 DOM 中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ title }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;{{ content }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 JavaScript 中，通过 Vue 实例的 &lt;code&gt;data&lt;/code&gt; 属性定义响应式数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;data&lt;/code&gt; 中的数据发生变化时，页面上绑定的内容会自动更新。&lt;/p&gt;
&lt;h2&gt;2.2 方法与插值表达式&lt;/h2&gt;
&lt;p&gt;Vue 允许在模板中调用方法。通过在 &lt;code&gt;methods&lt;/code&gt; 中定义函数，可以在插值表达式中使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ output() }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    },
    methods: {
        output() {
            return `Title: ${this.title}, Content: ${this.content}`;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3 计算属性&lt;/h2&gt;
&lt;p&gt;计算属性是基于依赖的缓存属性。当依赖的响应式数据发生变化时，计算属性会自动重新计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ outputContent }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义计算属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    },
    computed: {
        outputContent() {
            return `Title: ${this.title}, Content: ${this.content}`;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.4 侦听器（Watchers）&lt;/h2&gt;
&lt;p&gt;侦听器用于监听数据的变化，并执行特定的操作。通过在 &lt;code&gt;watch&lt;/code&gt; 中定义侦听器，可以实现更复杂的逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;
    },
    watch: {
        title(newVal, oldVal) {
            console.log(`Title changed from ${oldVal} to ${newVal}`);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;指令&lt;/h1&gt;
&lt;p&gt;Vue 提供了一系列指令，用于操作 DOM 和绑定数据。&lt;/p&gt;
&lt;h2&gt;3.1 条件渲染&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; 用于根据条件渲染元素。&lt;code&gt;v-if&lt;/code&gt; 是真正的条件渲染，而 &lt;code&gt;v-show&lt;/code&gt; 只是切换元素的 CSS 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-if=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
    &amp;lt;p v-show=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义布尔值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        bool: true
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.2 列表渲染&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-for&lt;/code&gt; 用于渲染列表数据。可以通过数组或对象进行循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-for=&quot;item in arr&quot;&amp;gt;{{ item }}&amp;lt;/p&amp;gt;
    &amp;lt;p v-for=&quot;(item, key, index) in obj&quot;&amp;gt;{{ item }} - {{ key }} - {{ index }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义数组和对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],
        obj: { a: 10, b: 20, c: 30 }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.3 属性绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-bind&lt;/code&gt; 用于动态绑定 DOM 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-bind:title=&quot;title&quot;&amp;gt;Hover over me to see the title.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义属性值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Dynamic Title&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.4 事件绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-on&lt;/code&gt; 或简写为 &lt;code&gt;@&lt;/code&gt; 用于绑定事件处理器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;button @click=&quot;output&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义事件处理方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    methods: {
        output() {
            alert(&apos;Button clicked!&apos;);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.5 表单绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 用于实现双向数据绑定，将表单输入与数据绑定在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ inputValue }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义绑定的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        inputValue: &apos;Default Value&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;修饰符&lt;/h1&gt;
&lt;p&gt;Vue 提供了一些修饰符，用于增强指令的功能。&lt;/p&gt;
&lt;h2&gt;4.1 事件修饰符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt; 修饰符用于去除输入值的首尾空格。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; v-model.trim=&quot;inputValue&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义绑定的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        inputValue: &apos;&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;示例代码&lt;/h1&gt;
&lt;p&gt;以下是完整的示例代码，展示了上述功能的综合应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;Vue 2.0 Quick Start&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;{{ content }}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;{{ outputContent }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-if=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
        &amp;lt;p v-show=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
        &amp;lt;p v-for=&quot;item in arr&quot;&amp;gt;{{ item }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-for=&quot;(item, key, index) in obj&quot;&amp;gt;{{ item }} - {{ key }} - {{ index }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-bind:title=&quot;title&quot;&amp;gt;Hover over me to see the title.&amp;lt;/p&amp;gt;
        &amp;lt;button @click=&quot;output&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
        &amp;lt;input type=&quot;text&quot; v-model.trim=&quot;inputValue&quot;&amp;gt;
        &amp;lt;p&amp;gt;{{ inputValue }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        new Vue({
            el: &apos;#app&apos;,
            data: {
                title: &apos;Hello Vue!&apos;,
                content: &apos;This is a Vue.js project.&apos;,
                bool: true,
                arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],
                obj: { a: 10, b: 20, c: 30 },
                inputValue: &apos;Default Value&apos;
            },
            methods: {
                output() {
                    alert(&apos;Button clicked!&apos;);
                }
            },
            computed: {
                outputContent() {
                    return `Title: ${this.title}, Content: ${this.content}`;
                }
            },
            watch: {
                title(newVal, oldVal) {
                    console.log(`Title changed from ${oldVal} to ${newVal}`);
                }
            }
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;通过以上内容，你已经掌握了 Vue 2.0 的基本语法和功能，包括响应式数据、插值表达式、指令、计算属性、侦听器和修饰符。这些功能将帮助你快速构建动态的用户界面。接下来，你可以通过阅读官方文档和实践更多项目，进一步提升你的 Vue.js 技能。&lt;/p&gt;
</content:encoded></item><item><title>CS205 Lab01</title><link>https://loners.site/posts/cs205-lab01/</link><guid isPermaLink="true">https://loners.site/posts/cs205-lab01/</guid><description>Welcome to my CS205 lecture notes!</description><pubDate>Tue, 18 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;Welcome to my CS205 lecture notes! Because the lecture is not in English, I will try my best to translate it.
And at the same time, the &lt;code&gt;PPT&lt;/code&gt;,&lt;code&gt;lab-file&lt;/code&gt; also use the English,I will write &lt;strong&gt;the English notes but not all.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
If you have a passion to konw more about the course, you can click the link below to learn more about the course.
Read the repo.&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;MongxinChan/CPP&quot;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Lab 1&lt;/h1&gt;
&lt;h2&gt;Task 1 Install WSL&lt;/h2&gt;
&lt;p&gt;install wsl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this task,I fail to install wsl.
So I do this :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl -l -o
wsl --install -d Ubuntu-20.04
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./pic/1.png&quot; alt=&quot;image-20250318003050449&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s my successful examples.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DISM.exe /Online /Enable-Feature /FeatureName:VirtualMachinePlatform /All /NoRestart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./pic/2.png&quot; alt=&quot;image-20250318003517641&quot; /&gt;&lt;/p&gt;
&lt;p&gt;use the &lt;code&gt;bash&lt;/code&gt; to start the system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl -l -v
wsl -d Ubuntu-24.04
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the username and password is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I donnot update in the markdown = =
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./pic/3.png&quot; alt=&quot;image-20250318004410701&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/4.png&quot; alt=&quot;4png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;we see that the &lt;code&gt;Ubuntu-24.04&lt;/code&gt; has been installed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/5.png&quot; alt=&quot;image-20250318004758417&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install g++ -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we use the commond to check their version up&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./pic/6.png&quot; alt=&quot;image-20250318090019674&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task 2 Use the WSL in visual studio code&lt;/h2&gt;
&lt;p&gt;Open the &lt;code&gt;vscode&lt;/code&gt;(Downloaded)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/7.png&quot; alt=&quot;7png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;O&lt;/code&gt; to command the system, and wait for a while to install the server of WSL&lt;/p&gt;
&lt;p&gt;If the connection is successful you will see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/8.png&quot; alt=&quot;8png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/9.png&quot; alt=&quot;9png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/mnt/d/Code/Cplusplus/SUST Cpp course/&lt;/code&gt; is a file path, typically used in a &lt;code&gt;Linux&lt;/code&gt; system to indicate a directory within a mounted Windows file system. Here’s a breakdown of its components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;/mnt/d&lt;/code&gt;&lt;/strong&gt;: In Linux, &lt;code&gt;/mnt&lt;/code&gt; is a mount point directory commonly used for mounting external storage devices or partitions. &lt;code&gt;/mnt/d&lt;/code&gt; indicates that the D drive from a Windows system is mounted here.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Task 3 Compile,Link and Run C/C++ Programs&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileProcession.png&quot; alt=&quot;image-20250404170927050&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileFileStep.png&quot; alt=&quot;image-20250404171355890&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The step called &lt;code&gt;Compile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileFileStep2.png&quot; alt=&quot;image-20250404171509663&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We create  the &lt;code&gt;.exe&lt;/code&gt; post-name-file. The step called &lt;code&gt;Linking&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileFileStep3.png&quot; alt=&quot;image-20250404171802256&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The default output executable file is called “a.exe”(Windows) or “a.out”(Unix  and Mac OS) if you don’t specify the name in compiling and linking step.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileFileStep4.png&quot; alt=&quot;image-20250404171945336&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You need to use &lt;code&gt;g++&lt;/code&gt; to compile C++ program. The &lt;code&gt;-o&lt;/code&gt; option is used to &lt;code&gt;specify the output file name&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileFileStep5.png&quot; alt=&quot;image-20250404172756641&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task# 4Terminal Output&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;printf&lt;/strong&gt;(format-control-string, other-arguments) f&lt;strong&gt;ormat-control-string&lt;/strong&gt; describes the output format, which consists of conversion specifiers, field  widths, precisions and literal characters with percent sign(%).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/Picture.png&quot; alt=&quot;Picture&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task# 5 Execrise&lt;/h2&gt;
&lt;p&gt;We couldnot directly compile the &lt;code&gt;main.cpp&lt;/code&gt; if we only compile the &lt;code&gt;main.cpp&lt;/code&gt; advoke &lt;code&gt;g++ -o main main.cpp &amp;amp;&amp;amp; ./main&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./pic/compileError.png&quot; alt=&quot;image-20250404173852592&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译 &lt;code&gt;add.cpp&lt;/code&gt; 文件生成对象文件&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ -c add.cpp -o add.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译 &lt;code&gt;main.cpp&lt;/code&gt; 文件生成对象文件&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ -c main.cpp -o main.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接两个对象文件生成可执行文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.o add.o -o myprogram.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;gcc -c add.cpp -o add.o
gcc -c main.cpp -o main.o
gcc main.o add.o -o myprogram -lstdc++
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cmake&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;步骤 1: 创建 CMakeLists.txt 文件&lt;/p&gt;
&lt;p&gt;在你的项目根目录下创建一个名为 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 的文件。这个文件将包含构建项目的指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.10)

# 项目名称
project(MyProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加源文件
add_executable(myprogram main.cpp add.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 2: 创建构建目录&lt;/p&gt;
&lt;p&gt;在项目根目录下创建一个名为 &lt;code&gt;build&lt;/code&gt; 的目录，用于存放构建文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir build
cd build
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 3: 运行 CMake&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;build&lt;/code&gt; 目录中运行 &lt;code&gt;cmake&lt;/code&gt; 命令，指定源代码目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会读取 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件，并生成适合你的系统的构建文件（如 Makefile 或 Visual Studio 解决方案文件）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 4: 编译项目&lt;/p&gt;
&lt;p&gt;使用生成的构建文件编译项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你使用的是 Makefile（通常是在 Unix-like 系统上）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你使用的是 Visual Studio（在 Windows 上）：&lt;/p&gt;
&lt;p&gt;打开生成的解决方案文件，并在 Visual Studio 中构建项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./pic/completed.png&quot; alt=&quot;completed&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>CS61B Lecture 2- 类与实例化，调试入门</title><link>https://loners.site/posts/cs61b-lecture2-cn/</link><guid isPermaLink="true">https://loners.site/posts/cs61b-lecture2-cn/</guid><description>这一讲介绍了类与其实例化，以及调试入门，我在后文提及了一下为什么会有面向对象编程，以及类，方法，实例的区别。</description><pubDate>Tue, 03 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;欢迎来到我的 CS61B 课程笔记！
在这份说明中，我将分享与&lt;a href=&quot;https://sp24.datastructur.es/&quot;&gt;CS61B&lt;/a&gt; &lt;code&gt;CS61B: Data Structures&lt;/code&gt; 相关的笔记和资源，该课程由 Justin Yokota 和 Peyrin Kao 讲授。&lt;/p&gt;
&lt;p&gt;我会发布我在课程期间完成的讲座笔记、作业和其他材料。我希望这些笔记能对正在修这门课的其他人有所帮助。如果你有任何问题或反馈，请随时联系我。感谢你的关注。
如果你想阅读英文版，请点击&lt;a href=&quot;https://www.loners.site/posts/cs61b-lecture2/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;CS61B 第2讲：类与实体，及调试入门&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Dog.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro;
public class Dog {
    public static void makeNoise() {
        System.out.println(&quot;Bark!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DogLauncher.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro;
public class DogLauncher {
    public static void main(String[] args) {
        Dog.makeNoise();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们运行 &lt;code&gt;DogLauncher.java&lt;/code&gt; 时，它会调用 &lt;code&gt;Dog&lt;/code&gt; 类并输出 &quot;Bark!&quot;。这很好，因为它允许我们使用不同的类将复杂的代码分解成更小的部分。&lt;/p&gt;
&lt;h2&gt;方法与类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每个方法（也称为函数）都与某个类相关联。&lt;/li&gt;
&lt;li&gt;要运行一个类，我们必须定义一个 &lt;code&gt;main&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;并非所有类都有 &lt;code&gt;main&lt;/code&gt; 方法！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建实例&lt;/strong&gt;
在编写方法和类时，我们通常希望模拟现实世界的特征。例如，每只狗的叫声可能不同，每个学生对铃声的反应也可能不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不太好的方法&lt;/strong&gt;
我们可以为每只狗创建一个单独的类，但这很快就会变得冗余。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：实例变量&lt;/strong&gt;
真正的解决方案是创建一个实体（实例），它可以代表特定的特征。例如，狗的叫声可以取决于它的体重。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class Dog {
    public int weightInPounds;

    public void makeNoise() {
        if (weightInPounds &amp;lt; 10) {
            System.out.println(&quot;yipyipyip!&quot;);
        } else if (weightInPounds &amp;lt; 30) {
            System.out.println(&quot;bark!&quot;);
        } else {
            System.out.println(&quot;aroooooooo!&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;带有实例的 DogLauncher.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class DogLauncher {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.weightInPounds = 20;
        d.makeNoise();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对象实例化&lt;/strong&gt;
类不仅可以包含函数（方法），还可以包含数据。例如，我们可以为每个 &lt;code&gt;Dog&lt;/code&gt; 添加一个 &lt;code&gt;size&lt;/code&gt; 变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类实例化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们创建一个单一的 &lt;code&gt;Dog&lt;/code&gt; 类，然后创建这个 &lt;code&gt;Dog&lt;/code&gt; 的实例。&lt;/li&gt;
&lt;li&gt;这些实例也被称为“对象”。&lt;/li&gt;
&lt;li&gt;类提供了一个所有 &lt;code&gt;Dog&lt;/code&gt; 对象都将遵循的蓝图。&lt;/li&gt;
&lt;li&gt;不能为 &lt;code&gt;Dog&lt;/code&gt; 添加新的实例变量；它们都必须完全遵循蓝图。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class Dog {
    public int weightInPounds;

    // 实例变量。可以有任意多个这样的变量。

    public Dog(int w) {
        weightInPounds = w;
    } // 构造函数（类似于方法但不是方法）。决定如何实例化类。

    public void makeNoise() {
        if (weightInPounds &amp;lt; 10) {
            System.out.println(&quot;yipyipyip!&quot;);
        } else if (weightInPounds &amp;lt; 30) {
            System.out.println(&quot;bark!&quot;);
        } else {
            System.out.println(&quot;aroooooooo!&quot;);
        }
    }

    // 非静态方法，也称为实例方法。理念：如果该方法将由类的实例调用，那么它应该是非静态的。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;静态与非静态方法&lt;/h2&gt;
&lt;p&gt;在同一个类中，我们可以同时拥有静态和非静态方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class Dog {
    public int weightInPounds;

    // 实例变量。可以有任意多个这样的变量。

    public Dog(int w) {
        weightInPounds = w;
    } // 构造函数（类似于方法但不是方法）。决定如何实例化类。

    public void makeNoise() {
        if (weightInPounds &amp;lt; 10) {
            System.out.println(&quot;yipyipyip!&quot;);
        } else if (weightInPounds &amp;lt; 30) {
            System.out.println(&quot;bark!&quot;);
        } else {
            System.out.println(&quot;aroooooooo!&quot;);
        }
    }

    // 非静态方法，也称为实例方法。理念：如果该方法将由类的实例调用，那么它应该是非静态的。

    public static Dog maxDoge(Dog d1, Dog d2) {
        if (d1.weightInPounds &amp;gt; d2.weightInPounds) {
            return d1;
        } else {
            return d2;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实例方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class Dog {
    // ...（前面的代码）

    public Dog maxDog(Dog d2) {
        if (weightInPounds &amp;gt; d2.weightInPounds) {
            return this;
        } else {
            return d2;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;带有静态和实例方法的 DogLauncher.java&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class DogLauncher {
    public static void main(String[] args) {
        Dog chester = new Dog(17);
        Dog yusuf = new Dog(150);

        Dog larger = chester.maxDoge(yusuf);
        larger.makeNoise();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态变量对整个类来说是通用的，而实例变量则特定于每个对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;交互式调试&lt;/strong&gt;
到目前为止（例如，在 CS61A 中），你可能通过添加打印语句来查找代码中的错误。今天，我们将使用 IntelliJ 的内置交互式调试工具来查找某些代码中的错误。调试更像是一门艺术，而不是科学。&lt;/p&gt;
&lt;h2&gt;示例：使用 IntelliJ 的调试器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package lec2_intro2;
public class DogLauncher {
    public static void main(String[] args) {
        Dog chester = new Dog(17);
        Dog yusuf = new Dog(150);

        Dog larger = Dog.maxDoge(chester, yusuf);
        larger.makeNoise();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类属性与实例属性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 定义类属性。&lt;/li&gt;
&lt;li&gt;没有 &lt;code&gt;static&lt;/code&gt;，则定义实例属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;类、实例和方法，这些概念对于新手来说往往容易混淆。实际上，它们的核心思想是通过代码对现实世界中的事物进行模拟和实现。&lt;/p&gt;
&lt;p&gt;我们常说类具有抽象性，那么抽象究竟是什么意思呢？在政治学中，抽象是从具体的社会现象中提炼出普遍规律，例如权力、自由、正义等概念；而在哲学中，抽象更多涉及认识论和本体论的讨论，比如如何通过抽象理解世界的本质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象并不是脱离具体的空谈，而是建立在具体事物基础上的提炼。我们需要从具体的事物中抽象出共性，这正是类的属性、方法和实例的意义所在。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以人类为例，一个独立的人可以看作是一个实例，他具有自己的属性（如姓名、年龄）和方法（如行走、思考）。&lt;/p&gt;
&lt;p&gt;但显然，人类并不是孤立的个体，我们既有人类的共性，也有每个人的独特性，这种独特性在Java中称之为&lt;strong&gt;多态性&lt;/strong&gt;(Polymorphism)。&lt;/p&gt;
&lt;p&gt;类的抽象性正是通过这种方式帮助我们描述世界：它既能捕捉事物的共性，又能保留个体的独特性。例如，人类是哺乳动物、恒温动物、有语言能力的动物，而企鹅是鸟类和恒温动物，但企鹅没有能飞的羽翼。我们可以说人类和企鹅同时&lt;strong&gt;继承&lt;/strong&gt;了恒温动物的特性，保持恒温，同样的，只是因为一些习性，这个体温各不相同。这就是所谓的&lt;strong&gt;继承&lt;/strong&gt;(Inheritance)，这种抽象模型让我们能够将事物关联起来，同时保留它们的差异。&lt;/p&gt;
&lt;p&gt;此外，类的&lt;strong&gt;封装性&lt;/strong&gt;也是一个重要特性。就像使用空调遥控器时，我们只需按下按钮，空调就会打开，而无需了解其内部工作原理。这种封装性通过隐藏复杂性，让使用者只需关注外界的输入和输出，从而简化了交互过程。&lt;/p&gt;
&lt;p&gt;最后，所谓实例化，就是将一个类转化为具体的对象。这个对象不仅继承了类的共性，还具有自己的独特性。例如，张三和李四都是人类的实例，他们听到打铃时会下意识地跑向自己的教室，但他们的名字和行为细节却各不相同。&lt;/p&gt;
&lt;p&gt;通过这些概念，我们能够更清晰地描述和操作现实世界中的复杂关系，同时让代码更具组织性和可维护性。&lt;/p&gt;
</content:encoded></item><item><title>CS61B Lecture 1 - 课程介绍</title><link>https://loners.site/posts/cs61b-lecture1-cn/</link><guid isPermaLink="true">https://loners.site/posts/cs61b-lecture1-cn/</guid><description>CS61B Lecture 1 CN，主要讲的是如何使用Java的基础语法，以及CS61B课程的介绍。</description><pubDate>Mon, 02 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;欢迎来到我的 CS61B 课程笔记！
在这份说明中，我将分享与&lt;a href=&quot;https://sp24.datastructur.es/&quot;&gt;CS61B&lt;/a&gt; &lt;code&gt;CS61B: Data Structures&lt;/code&gt; 相关的笔记和资源，该课程由 Justin Yokota 和 Peyrin Kao 讲授。&lt;/p&gt;
&lt;p&gt;我会发布我在课程期间完成的讲座笔记、作业和其他材料。我希望这些笔记能对正在修这门课的其他人有所帮助。如果你有任何问题或反馈，请随时联系我。感谢你的关注。
如果你想阅读英文版，请点击&lt;a href=&quot;https://www.loners.site/posts/cs61b-lecture1/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;CS61B课程笔记&lt;/h1&gt;
&lt;p&gt;可以直接跳过对未来的展望，这一部分主要是对UCB的学生的考核，当然你也可以参考一下UCB对学生的要求~&lt;/p&gt;
&lt;h2&gt;课程介绍&lt;/h2&gt;
&lt;p&gt;CS61B课程主要关注以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编写高效的代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;良好的算法&lt;/li&gt;
&lt;li&gt;良好的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效地编写代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设计、构建、测试和调试大型程序&lt;/li&gt;
&lt;li&gt;使用编程工具
&lt;ul&gt;
&lt;li&gt;git、IntelliJ、JUnit和各种命令行工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java（不是课程的重点）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;课程假设学生具备以下编程基础：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向对象编程、递归、列表和树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CS61B的其他精彩之处：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;软件工程面试中最受欢迎的主题&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;示例：哈希表、二叉搜索树、快速排序、图、Dijkstra算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一些非常酷的数学&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;示例：
&lt;ul&gt;
&lt;li&gt;渐近分析&lt;/li&gt;
&lt;li&gt;数组扩容&lt;/li&gt;
&lt;li&gt;自平衡2-3树与自平衡红黑树的等距性&lt;/li&gt;
&lt;li&gt;图论&lt;/li&gt;
&lt;li&gt;P=NP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成后：&lt;/strong&gt; &lt;strong&gt;有信心可以构建任何软件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;你希望/期望从这门课中学到什么？你为什么选这门课？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作&lt;/li&gt;
&lt;li&gt;我终于可以让我的代码高效运行了&lt;/li&gt;
&lt;li&gt;我想要得A&lt;/li&gt;
&lt;li&gt;从零开始编码&lt;/li&gt;
&lt;li&gt;更好地掌握数据结构和算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;你是谁？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大一？大二？大三？大四？研究生？以上都不是？&lt;/li&gt;
&lt;li&gt;计算机科学专业？打算成为计算机科学专业？其他？&lt;/li&gt;
&lt;li&gt;修过CS61A？有Java经验吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;当你离开这门课时，我希望每个人都能为了乐趣而编写程序，因为他们有一些需要解决的问题，或者他们只是想浪费一个周末做点什么。
--Peryin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;课程组成部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;讲座&lt;/strong&gt;为你提供介绍和基础。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你将通过以下方式学习大部分课程内容：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;编程（实验、作业、项目、讨论课）&lt;/li&gt;
&lt;li&gt;解决有趣的问题（学习指南、作业3、作业4、旧考试题、讨论课）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般来说，你会通过实践学到很多。编程不是仅靠理论就能学会的。&lt;/strong&gt; 你需要真正去实践。因此，你会通过作业、实验和项目获得大量用Java编程的经验。&lt;strong&gt;讨论课不会直接进行编程，但你会讨论很多关于如何有效编码的内容。&lt;/strong&gt; 整个学期你将解决很多有趣的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;评估&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这门课有四种类型的分数：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;**低努力，每个人都应该得到：**每周调查、课程评估
&lt;ul&gt;
&lt;li&gt;中位数分数为100%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**高努力，每个人都应该得到：**作业、项目、实验
&lt;ul&gt;
&lt;li&gt;中位数分数为100%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**高努力，不是每个人都得到：**考试
&lt;ul&gt;
&lt;li&gt;平均分数为65%&lt;/li&gt;
&lt;li&gt;如果你在期中考试中表现不佳（或两次），期末考试分数可以替代期中考试分数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**进度分数：**参加讨论课、实验课并跟上讲座进度
&lt;ul&gt;
&lt;li&gt;跟上课程进度可获得少量额外学分&lt;/li&gt;
&lt;li&gt;不会将你的分数提高到超过75%（B-）
&lt;ul&gt;
&lt;li&gt;示例：你有740分并获得20个进度分数，你将得到750分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**B到B+的门槛：**考试65%，其他部分95%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;课程阶段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一阶段（第1-4周）：Java和数据结构入门&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;所有编码工作都是个人完成&lt;/li&gt;
&lt;li&gt;进度非常快&lt;/li&gt;
&lt;li&gt;作业0（Java入门）将在周五到期（还有两天！）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二阶段（第5-10周）：数据结构&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;所有编码工作都是个人完成&lt;/li&gt;
&lt;li&gt;进度适中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三阶段（第12-14周）：算法&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;编码工作完全用于最终项目，由两人一组完成&lt;/li&gt;
&lt;li&gt;进度较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;Java入门&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;print(&quot;hello world&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java是一种非常注重面向对象编程的语言。&lt;/strong&gt;&lt;br /&gt;
它非常注重你编写的代码都在一个类中。让我们来创建一个类。我将使用 &lt;em&gt;魔术词&lt;/em&gt; &lt;code&gt;public class&lt;/code&gt; 来定义一个类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(&quot;hello world&quot;); // print不包含&quot;\n&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Java与面向对象编程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于Hello World的反思：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Java中，所有代码都必须是类的一部分&lt;/li&gt;
&lt;li&gt;类使用 &lt;code&gt;public class CLASSNAME&lt;/code&gt; 定义&lt;/li&gt;
&lt;li&gt;我们使用 &lt;code&gt;{ }&lt;/code&gt; 来划分事物的开始和结束&lt;/li&gt;
&lt;li&gt;我们必须用分号结束一行&lt;/li&gt;
&lt;li&gt;我们想要运行的代码必须在 &lt;code&gt;public static void main(String[] args)&lt;/code&gt; 中
&lt;ul&gt;
&lt;li&gt;我们稍后会学习这意味着什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java是一种具有严格要求的面向对象语言：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个Java文件必须包含一个类声明&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有代码&lt;/strong&gt; 都在一个类中，即使是辅助函数、全局常量等&lt;/li&gt;
&lt;li&gt;要运行Java程序，你通常需要使用 &lt;code&gt;public static void main(String[] args)&lt;/code&gt; 定义一个main方法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Java与Python：静态类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = 0
while x &amp;lt; 10:
    print(x)
    x = x + 1
x = &quot;horse&quot;
print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HelloNumbers {
    public static void main(String[] args) {
        int x = 0;
        while (x &amp;lt; 10) {
            System.out.println(x);
            x = x + 1;
        }
        x = &quot;horse&quot;; // 这将导致编译时错误
        System.out.println(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关于Hello Numbers的反思：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Java中使用变量之前，必须先声明&lt;/li&gt;
&lt;li&gt;Java变量必须有一个特定的类型&lt;/li&gt;
&lt;li&gt;Java变量的类型不能改变&lt;/li&gt;
&lt;li&gt;类型在代码运行之前就会被验证！&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Java与静态类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java是静态类型的！&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;所有变量、参数和方法都必须有一个声明的类型&lt;/li&gt;
&lt;li&gt;该类型不能改变&lt;/li&gt;
&lt;li&gt;表达式也有类型，例如 &lt;code&gt;larger(5, 1) + 3&lt;/code&gt; 的类型为 &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译器会在程序运行之前检查程序中的所有类型是否兼容！
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;String x = larger(5, 10) + 3&lt;/code&gt; 将无法编译&lt;/li&gt;
&lt;li&gt;这与Python不同，Python在执行期间进行类型检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;在Java中编写函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def larger(x, y):
    if x &amp;gt; y:
        return x
    else:
        return y

print(larger(-5, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LargeDemo {
    public static int larger(int x, int y) {
        if (x &amp;gt; y) {
            return x;
        } else {
            return y;
        }
    }

    public static void main(String[] args) {
        System.out.println(larger(5, 4));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关于Larger的反思：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Java中，函数必须作为类的一部分声明。作为类一部分的函数称为“方法”&lt;/li&gt;
&lt;li&gt;要在Java中定义一个函数，我们使用 &lt;code&gt;public static&lt;/code&gt;。我们稍后会看到定义函数的其他方法&lt;/li&gt;
&lt;li&gt;函数的所有参数都必须有一个声明的类型，函数的返回值也必须有一个声明的类型。Java中的函数只返回一个值！&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;面向对象编程回顾&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一种组织程序的模型&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模块化：&lt;/strong&gt; 定义每个部分而不必担心其他部分，它们都能一起工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据抽象：&lt;/strong&gt; 你可以与对象交互而不必知道它是如何实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;对象将信息和相关行为捆绑在一起&lt;/li&gt;
&lt;li&gt;每个对象都有自己的本地状态&lt;/li&gt;
&lt;li&gt;几个对象可能都是某个共同类型的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;类作为其所有实例的模板&lt;/li&gt;
&lt;li&gt;每个对象都是某个类的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Python、Java和C++中的类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Car:
    def __init__(self, m):
        self.model = m
        self.wheels = 4

    def drive(self):
        if self.wheels &amp;lt; 4:
            print(self.model + &quot; no go vroom&quot;)
            return
        print(self.model + &quot; goes vroom&quot;)

    def getNumWheels(self):
        return self.wheels

    def driveIntoDitch(self, wheelsLost):
        self.wheels = self.wheels - wheelsLost

c1 = Car(&quot;Civic Type R&quot;)
c2 = Car(&quot;Porsche 911&quot;)
c1.drive()
c1.driveIntoDitch(2)
c1.drive()

print(c2.getNumWheels())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Car {
    public String model;
    public int wheels;

    public Car(String m) {
        this.model = m;
        this.wheels = 4;
    }

    public void drive() {
        if (this.wheels &amp;lt; 4) {
            System.out.println(this.model + &quot; no go vroom&quot;);
            return;
        }
        System.out.println(this.model + &quot; go vroom&quot;);
    }

    public int getNumWheels() {
        return this.wheels;
    }

    public void driveIntoDitch(int wheelsLost) {
        this.wheels = this.wheels - wheelsLost;
    }

    public static void main(String[] args) {
        Car c1 = new Car(&quot;Porsche 911&quot;);
        Car c2 = new Car(&quot;Toyota Camry&quot;);

        c1.drive();
        c1.driveIntoDitch(2);
        c1.drive();

        System.out.println(c2.getNumWheels());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;C++:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Car {
public:
    string model;
    int wheels;

    Car(string m) {
        this-&amp;gt;model = m;
        this-&amp;gt;wheels = 4;
    }

    void drive() {
        if (this-&amp;gt;wheels &amp;lt; 4) {
            cout &amp;lt;&amp;lt; this-&amp;gt;model &amp;lt;&amp;lt; &quot; no vroom.&quot; &amp;lt;&amp;lt; endl;
            return;
        }
        cout &amp;lt;&amp;lt; this-&amp;gt;model &amp;lt;&amp;lt; &quot; vroom.&quot; &amp;lt;&amp;lt; endl;
    }

    int getNumWheels() {
        return this-&amp;gt;wheels;
    }

    void driveIntoDitch(int wheelsLost) {
        this-&amp;gt;wheels = this-&amp;gt;wheels - wheelsLost;
    }
};

int main() {
    Car* c1 = new Car(&quot;Toyota Camry&quot;);
    Car* c2 = new Car(&quot;Porsche 911&quot;);

    c1-&amp;gt;drive();
    c1-&amp;gt;driveIntoDitch(2);
    c1-&amp;gt;drive();

    c2-&amp;gt;drive();
    cout &amp;lt;&amp;lt; c2-&amp;gt;getNumWheels() &amp;lt;&amp;lt; endl;

    delete c1;
    delete c2; // 避免内存泄漏

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;面向对象编程回顾&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一种组织程序的模型&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模块化：&lt;/strong&gt; 定义每个部分而不必担心其他部分，它们都能一起工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据抽象：&lt;/strong&gt; 你可以与对象交互而不必知道它是如何实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;对象将信息和相关行为捆绑在一起&lt;/li&gt;
&lt;li&gt;每个对象都有自己的本地状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;写在最后&lt;/h1&gt;
&lt;p&gt;作为一名中国学生，当我接触到CS61B的课程内容时，不禁感慨万千。这样的课程，才是计算机专业学生真正应该学习的内容。相比之下，国内许多课程却过于专注于语法细节和机械化的应试训练，缺乏对计算机科学本质的深入探索。这让我时常思考：为什么大学教育总是被批评为与社会生产脱节？其实，问题的根源在于教学内容的停滞不前。
在国内，课程内容的陈旧并非偶然。一方面，改变课程大纲意味着教师需要重新设计教学方案，这无疑增加了备课的难度和工作量；另一方面，学生也可能因为内容难度的提升而面临更高的挂科风险。因此，许多学校和教师选择维持现状，继续沿用那些陈旧的知识体系。这种“路径依赖”导致了多年来大学课程内容的固化，甚至与时代需求渐行渐远。
这也是我选择深入学习公开课的原因之一。通过接触像CS61B这样注重理论与实践结合的课程，我希望能够弥补国内教育的不足，真正理解计算机科学的核心思想和实际应用。这种学习不仅是对个人能力的提升，更是对教育现状的一种反思和回应。&lt;/p&gt;
</content:encoded></item><item><title>CS61B Lecture 1</title><link>https://loners.site/posts/cs61b-lecture1/</link><guid isPermaLink="true">https://loners.site/posts/cs61b-lecture1/</guid><description>Welcome to my CS61B lecture notes!</description><pubDate>Sun, 01 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;Welcome to my CS61B lecture notes!
In this notice, I will be sharing my notes and resources related to &lt;a href=&quot;https://sp24.datastructur.es/&quot;&gt;the course&lt;/a&gt; &lt;code&gt;CS61B: Data Structures&lt;/code&gt; taught by Justin Yokota and Peyrin Kao .
I will be posting my lecture notes, assignments, and other materials that I have completed during the course. I hope that these notes will be helpful to others who are taking the course. If you have any questions or feedback, please feel free to contact me. Thank you for your attention.&lt;/p&gt;
&lt;p&gt;If you wanna read the Chinese Edition,&lt;a href=&quot;https://www.loners.site/posts/cs61b-lecture1-cn/&quot;&gt;Click Here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;The lecture shows the different between Java and Python(CS61A).
I will try my best to translate it.
And at the same time, the &lt;code&gt;PPT&lt;/code&gt;,&lt;code&gt;lab-file&lt;/code&gt; also use the English,I will write &lt;strong&gt;the English notes but not all.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;What is CS61B about?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Writing code that runs efficiently&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Good algorithms&lt;/li&gt;
&lt;li&gt;Good data structures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Writing code efficiently&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Designing, building, testing, and debugging large programs&lt;/li&gt;
&lt;li&gt;Use of programming tools
&lt;ul&gt;
&lt;li&gt;git, IntelliJ, JUnit, and various command line tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java (not the focus of the course)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Assumes a solid foundation in programming fundamentals, including:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Object-oriented programming, recursion, lists, and trees&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Other Great Features of CS61B:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The most popular topics for job interview questions in software engineering&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Examples: Hash tables, binary search trees, quick sort, graphs, Dijkstra&apos;s algorithm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Some really cool math&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Examples:
&lt;ul&gt;
&lt;li&gt;Asymptotic analysis&lt;/li&gt;
&lt;li&gt;Resizing arrays&lt;/li&gt;
&lt;li&gt;The isometry between self-balancing 2-3 trees and self-balancing red-black trees&lt;/li&gt;
&lt;li&gt;Graph theory&lt;/li&gt;
&lt;li&gt;P=NP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Once you&apos;re done: The confident sense that you can build any software&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Question for You&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;What do you hope/expect to learn from this class? Why are you taking it?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;li&gt;I want to be able to run my code efficiently (finally)&lt;/li&gt;
&lt;li&gt;I want an A&lt;/li&gt;
&lt;li&gt;Coding from scratch&lt;/li&gt;
&lt;li&gt;Greater grasp of data structures and algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Who are you?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Freshman? Sophomore? Junior? Senior? Grad student? None of the above?&lt;/li&gt;
&lt;li&gt;CS Major? Intending to be a CS Major? Something else?&lt;/li&gt;
&lt;li&gt;CS 61A? Java experience&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;By the time you leave this class, I want everyone to be able to write a program just for fun, because they have some problems they need to solve or they just want to, I donot konw, waste a weekend doing something.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Course Components&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lectures&lt;/strong&gt; provide you with an introduction and a foundation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You&apos;ll learn most of what you learn in the class by:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Programming (labs, homeworks, projects, discussion sections)&lt;/li&gt;
&lt;li&gt;Solving interesting problems (study guides, HW3, HW4, old exam problems, discussion sections)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Generally speaking, you&apos;ll learn a lot through doing. Programming is not something you can learn just from theory.&lt;/strong&gt; You have to actually practice it. So you&apos;ll be getting a lot of experience with programming Java through your homeworks, labs, and projects. &lt;strong&gt;Discussion won&apos;t do direct programming, but you&apos;ll be discussing a lot about how to code effectively.&lt;/strong&gt; You&apos;ll get to solve a lot of interesting problems throughout the semester.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Evaluation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Four types of points in this class:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Low effort, everyone should get them:&lt;/strong&gt; Weekly Surveys, Course Evaluations
&lt;ul&gt;
&lt;li&gt;Median score is 100%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High effort, everyone should get them:&lt;/strong&gt; HW, Project, Lab
&lt;ul&gt;
&lt;li&gt;Median score is 100%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High effort, not everyone gets them:&lt;/strong&gt; Exams
&lt;ul&gt;
&lt;li&gt;Mean score is 65%&lt;/li&gt;
&lt;li&gt;Final exam score can replace midterms if you have a bad midterm (or two)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pacing points:&lt;/strong&gt; Attending Discussion, Lab, and keeping up with Lecture
&lt;ul&gt;
&lt;li&gt;Small amount of extra credit for keeping up with class&lt;/li&gt;
&lt;li&gt;Will not increase your score beyond 75% (B-)
&lt;ul&gt;
&lt;li&gt;Example: You have 740 points and earn 20 pacing points, you get 750 points&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B to B+ threshold:&lt;/strong&gt; 65% on exams, 95% on everything else&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Class Phases&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Phase 1 (Weeks 1-4): Intro to Java and Data Structures&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;All coding work is solo&lt;/li&gt;
&lt;li&gt;Moves VERY fast&lt;/li&gt;
&lt;li&gt;HW0 (intro to Java) due Friday (in two days!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phase 2 (Weeks 5-10): Data Structures&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;All coding work is solo&lt;/li&gt;
&lt;li&gt;Moves moderately fast&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phase 3 (Weeks 12-14): Algorithms&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Coding work is entirely dedicated to final project, done in pairs&lt;/li&gt;
&lt;li&gt;Slower pace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;Intro to Java&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;print(&quot;hello world&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;If we screw up,we&apos;ll screw it together.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Java is a language that cares very much about object-oriented programming.&lt;/strong&gt;&lt;br /&gt;
It really cares that all the code you write is in a class. Let&apos;s make a class. The &lt;em&gt;magic words&lt;/em&gt; I&apos;m going to use to define a class are &lt;code&gt;public class&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(&quot;hello world&quot;); // print not include &quot;\n&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Java and Object Orientation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Reflections on Hello World:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In Java, all code must be part of a class&lt;/li&gt;
&lt;li&gt;Classes are defined with &lt;code&gt;public class CLASSNAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We use &lt;code&gt;{ }&lt;/code&gt; to delineate the beginning and ending of things&lt;/li&gt;
&lt;li&gt;We must end lines with a semicolon&lt;/li&gt;
&lt;li&gt;The code we want to run must be inside &lt;code&gt;public static void main(String[] args)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;We&apos;ll learn what this means later&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java is an object-oriented language with strict requirements:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every Java file must contain a class declaration&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All code&lt;/strong&gt; lives inside a class, even helper functions, global constants, etc.&lt;/li&gt;
&lt;li&gt;To run a Java program, you typically define a main method using &lt;code&gt;public static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Java vs. Python: Static Typing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = 0
while x &amp;lt; 10:
    print(x)
    x = x + 1
x = &quot;horse&quot;
print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HelloNumbers {
    public static void main(String[] args) {
        int x = 0;
        while (x &amp;lt; 10) {
            System.out.println(x);
            x = x + 1;
        }
        x = &quot;horse&quot;; // This will cause a compile-time error
        System.out.println(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Reflections on Hello Numbers:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before Java variables can be used, they must be declared&lt;/li&gt;
&lt;li&gt;Java variables must have a specific type&lt;/li&gt;
&lt;li&gt;Java variable types can never change&lt;/li&gt;
&lt;li&gt;Types are verified before the code even runs!&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Java and Static Typing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java is statically typed!&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;All variables, parameters, and methods must have a declared type&lt;/li&gt;
&lt;li&gt;That type can never change&lt;/li&gt;
&lt;li&gt;Expressions also have a type, e.g., &lt;code&gt;larger(5, 1) + 3&lt;/code&gt; has type &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The compiler checks that all the types in your program are compatible before the program ever runs!
&lt;ul&gt;
&lt;li&gt;e.g., &lt;code&gt;String x = larger(5, 10) + 3&lt;/code&gt; will fail to compile&lt;/li&gt;
&lt;li&gt;This is unlike a language like Python, where type checks are performed during execution&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Writing a Function in Java&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def larger(x, y):
    if x &amp;gt; y:
        return x
    else:
        return y

print(larger(-5, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LargeDemo {
    public static int larger(int x, int y) {
        if (x &amp;gt; y) {
            return x;
        } else {
            return y;
        }
    }

    public static void main(String[] args) {
        System.out.println(larger(5, 4));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Reflections on Larger:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functions &lt;strong&gt;must&lt;/strong&gt; be declared as part of a class in Java. A method that is part of a class is called a &quot;method&quot;&lt;/li&gt;
&lt;li&gt;To define a function in Java, we use &lt;code&gt;public static&lt;/code&gt;. We will see alternate ways of defining functions later&lt;/li&gt;
&lt;li&gt;All parameters of a function must have a declared type, and the return value of the function must have a declared type. Functions in Java return only one value!&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;Review: Object-Oriented Programming&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A model for organizing programs&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Modularity:&lt;/strong&gt; Define each piece without worrying about other pieces, and they all work together&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data abstraction:&lt;/strong&gt; You can interact with an object without knowing how it&apos;s implemented&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objects&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;An object bundles together information and related behavior&lt;/li&gt;
&lt;li&gt;Each object has its own local state&lt;/li&gt;
&lt;li&gt;Several objects may all be instances of a common type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Classes&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;A class serves as a template for all of its instances&lt;/li&gt;
&lt;li&gt;Each object is an instance of some class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Classes in Python, Java, and C++&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Car:
    def __init__(self, m):
        self.model = m
        self.wheels = 4

    def drive(self):
        if self.wheels &amp;lt; 4:
            print(self.model + &quot; no go vroom&quot;)
            return
        print(self.model + &quot; goes vroom&quot;)

    def getNumWheels(self):
        return self.wheels

    def driveIntoDitch(self, wheelsLost):
        self.wheels = self.wheels - wheelsLost

c1 = Car(&quot;Civic Type R&quot;)
c2 = Car(&quot;Porsche 911&quot;)
c1.drive()
c1.driveIntoDitch(2)
c1.drive()

print(c2.getNumWheels())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Car {
    public String model;
    public int wheels;

    public Car(String m) {
        this.model = m;
        this.wheels = 4;
    }

    public void drive() {
        if (this.wheels &amp;lt; 4) {
            System.out.println(this.model + &quot; no go vroom&quot;);
            return;
        }
        System.out.println(this.model + &quot; go vroom&quot;);
    }

    public int getNumWheels() {
        return this.wheels;
    }

    public void driveIntoDitch(int wheelsLost) {
        this.wheels = this.wheels - wheelsLost;
    }

    public static void main(String[] args) {
        Car c1 = new Car(&quot;Porsche 911&quot;);
        Car c2 = new Car(&quot;Toyota Camry&quot;);

        c1.drive();
        c1.driveIntoDitch(2);
        c1.drive();

        System.out.println(c2.getNumWheels());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;C++:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Car {
public:
    string model;
    int wheels;

    Car(string m) {
        this-&amp;gt;model = m;
        this-&amp;gt;wheels = 4;
    }

    void drive() {
        if (this-&amp;gt;wheels &amp;lt; 4) {
            cout &amp;lt;&amp;lt; this-&amp;gt;model &amp;lt;&amp;lt; &quot; no vroom.&quot; &amp;lt;&amp;lt; endl;
            return;
        }
        cout &amp;lt;&amp;lt; this-&amp;gt;model &amp;lt;&amp;lt; &quot; vroom.&quot; &amp;lt;&amp;lt; endl;
    }

    int getNumWheels() {
        return this-&amp;gt;wheels;
    }

    void driveIntoDitch(int wheelsLost) {
        this-&amp;gt;wheels = this-&amp;gt;wheels - wheelsLost;
    }
};

int main() {
    Car* c1 = new Car(&quot;Toyota Camry&quot;);
    Car* c2 = new Car(&quot;Porsche 911&quot;);

    c1-&amp;gt;drive();
    c1-&amp;gt;driveIntoDitch(2);
    c1-&amp;gt;drive();

    c2-&amp;gt;drive();
    cout &amp;lt;&amp;lt; c2-&amp;gt;getNumWheels() &amp;lt;&amp;lt; endl;

    delete c1;
    delete c2; // Avoid memory leaks

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Review: Object-Oriented Programming&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A model for organizing programs&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Modularity:&lt;/strong&gt; Define each piece without worrying about other pieces, and they all work together&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data abstraction:&lt;/strong&gt; You can interact with an object without knowing how it&apos;s implemented&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objects&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;An object bundles together information and related behavior&lt;/li&gt;
&lt;li&gt;Each object has its own local state&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Some words in the end:&lt;/h1&gt;
&lt;p&gt;As a student from China, I am deeply impressed by the content of CS61B. This is truly what computer science education should be—focusing on the essence of the field rather than fixating on syntax or rote memorization for exams. It often makes me reflect on the common critique that university education is disconnected from real-world demands. The root of the problem lies in the stagnation of curricula.
In many domestic contexts, outdated course content persists for several reasons. First, revising syllabi would require instructors to redesign their teaching materials, which increases their workload and complicates lesson preparation. Second, students might struggle with higher failure rates if the content becomes more challenging. As a result, universities and instructors often prefer to maintain the status quo, perpetuating a cycle of outdated knowledge. This &quot;path dependency&quot; has caused a growing disconnect between university curricula and the demands of the modern world.
This is one of the reasons I am committed to studying open courses like CS61B. By engaging with curricula that emphasize both theory and practical application, I aim to bridge the gaps in domestic education and gain a deeper understanding of the core principles and real-world applications of computer science. This learning journey is not only about personal growth but also a reflection on and response to the current state of education.&lt;/p&gt;
</content:encoded></item><item><title>虚函数：C++ 多态的核心</title><link>https://loners.site/posts/cpp-%E8%99%9A%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://loners.site/posts/cpp-%E8%99%9A%E5%87%BD%E6%95%B0/</guid><description>在面向对象编程中，多态是一种强大的特性，它允许我们通过基类的接口调用派生类的实现。C++ 中的虚函数（Virtual Function）是实现多态的关键机制。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。重载函数主要用于编译时的多态（静态绑定），而虚函数则用于运行时的多态（动态绑定）。</description><pubDate>Sat, 23 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;在面向对象编程中，多态是一种强大的特性，它允许我们通过基类的接口调用派生类的实现。C++ 中的虚函数（Virtual Function）是实现多态的关键机制。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。重载函数主要用于编译时的多态（静态绑定），而虚函数则用于运行时的多态（动态绑定）。&lt;/p&gt;
&lt;p&gt;虚函数的实现依赖于一个隐藏的数据结构——虚表（Virtual Table，简称 vtable）。虚表是一个函数指针数组，存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;p&gt;理解虚函数和虚表的工作原理，对于深入掌握 C++ 的对象模型和性能优化至关重要。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的设计理念&lt;/h1&gt;
&lt;p&gt;虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重载函数（Overloading）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：通过相同的函数名和不同的参数列表，提供多种函数实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：编译时多态（静态绑定）。编译器根据函数的参数类型和数量选择正确的函数版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;void print(int x) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(double x) { cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;虚函数（Virtual Function）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：通过基类的接口调用派生类的实现，实现运行时多态（动态绑定）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：运行时多态。通过虚表（vtable）和虚指针（vptr）动态选择正确的函数版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚函数的设计理念是为了解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在运行时动态选择函数的实现？&lt;/li&gt;
&lt;li&gt;如何通过基类的指针或引用调用派生类的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的定义与使用&lt;/h1&gt;
&lt;h2&gt;虚函数的定义&lt;/h2&gt;
&lt;p&gt;虚函数通过在函数声明前加上 &lt;code&gt;virtual&lt;/code&gt; 关键字来定义。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚函数的声明表示该函数可以在派生类中被重写（override）。如果派生类没有重写虚函数，则会继承基类的实现。&lt;/p&gt;
&lt;h2&gt;虚函数的使用&lt;/h2&gt;
&lt;p&gt;虚函数的使用依赖于基类的指针或引用。通过基类的指针或引用调用虚函数时，实际调用的是派生类的实现（如果派生类重写了该虚函数）。这种机制称为动态绑定（Dynamic Binding）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    Base* ptr = new Derived();
    ptr-&amp;gt;print(); // 输出 Derived::print()
    delete ptr;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数的继承&lt;/h2&gt;
&lt;p&gt;当派生类继承自基类时，派生类会继承基类的虚函数。如果派生类重写了基类的虚函数，虚表中的相应条目会被更新为派生类的函数地址。如果派生类没有重写某些虚函数，虚表中的条目则保持基类的函数地址。&lt;/p&gt;
&lt;h2&gt;虚函数的覆盖（Override）&lt;/h2&gt;
&lt;p&gt;派生类可以通过重写基类的虚函数来覆盖其行为。使用 &lt;code&gt;override&lt;/code&gt; 关键字可以显式地表示覆盖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数的隐藏（Hide）&lt;/h2&gt;
&lt;p&gt;如果派生类定义了一个与基类虚函数同名但参数列表不同的函数，这将隐藏基类的虚函数，而不是覆盖它。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print(int x) { cout &amp;lt;&amp;lt; &quot;Base::print(int)&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; } // 隐藏了 Base::print(int)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;纯虚函数与抽象类&lt;/h1&gt;
&lt;h2&gt;纯虚函数&lt;/h2&gt;
&lt;p&gt;纯虚函数是一种特殊的虚函数，它没有具体的实现，仅在基类中声明。纯虚函数的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0; // 纯虚函数
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;纯虚函数的定义表示该函数必须在派生类中被实现。如果派生类没有实现纯虚函数，则该派生类也是抽象类。&lt;/p&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;p&gt;包含纯虚函数的类称为抽象类。抽象类不能被实例化，只能作为基类被派生。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    // Base b; // 错误！抽象类不能被实例化
    Derived d;
    d.print(); // 输出 Derived::print()
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;纯虚函数的实现&lt;/h2&gt;
&lt;p&gt;虽然纯虚函数没有默认实现，但可以在基类中提供一个默认实现。派生类可以选择性地覆盖该实现。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0 {
        cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl;
    }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;虚表（Virtual Table）的实现&lt;/h1&gt;
&lt;p&gt;虚表是 C++ 编译器为每个包含虚函数的类生成的一个隐藏的数据结构。虚表是一个函数指针数组，存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;h2&gt;虚表的结构&lt;/h2&gt;
&lt;p&gt;假设我们有以下类定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void f1() { cout &amp;lt;&amp;lt; &quot;Base::f1&quot; &amp;lt;&amp;lt; endl; }
    virtual void f2() { cout &amp;lt;&amp;lt; &quot;Base::f2&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void f1() override { cout &amp;lt;&amp;lt; &quot;Derived::f1&quot; &amp;lt;&amp;lt; endl; }
    void f2() override { cout &amp;lt;&amp;lt; &quot;Derived::f2&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器会为 &lt;code&gt;Base&lt;/code&gt; 和 &lt;code&gt;Derived&lt;/code&gt; 类生成虚表，其结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Base 类的虚表&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Base::f1&lt;/code&gt; 的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Base::f2&lt;/code&gt; 的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Derived 类的虚表&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Derived::f1&lt;/code&gt; 的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Derived::f2&lt;/code&gt; 的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;虚表的内存布局&lt;/h2&gt;
&lt;p&gt;假设 &lt;code&gt;Base&lt;/code&gt; 和 &lt;code&gt;Derived&lt;/code&gt; 类的对象在内存中的布局如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Base 对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vptr（指向 Base 的虚表）&lt;/li&gt;
&lt;li&gt;其他成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Derived 对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vptr（指向 Derived 的虚表）&lt;/li&gt;
&lt;li&gt;其他成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当通过基类指针调用虚函数时，程序通过 vptr 查找虚表，找到对应的函数地址并调用。这种机制确保了多态的实现。&lt;/p&gt;
&lt;h2&gt;虚表的初始化&lt;/h2&gt;
&lt;p&gt;当对象被创建时，构造函数会初始化对象的 vptr，使其指向正确的虚表。如果对象是派生类的实例，vptr 会被初始化为指向派生类的虚表。&lt;/p&gt;
&lt;h2&gt;虚表的继承&lt;/h2&gt;
&lt;p&gt;当派生类继承自基类时，派生类会继承基类的虚表。如果派生类重写了基类的虚函数，虚表中的相应条目会被更新为派生类的函数地址。如果派生类没有重写某些虚函数，虚表中的条目则保持基类的函数地址。&lt;/p&gt;
&lt;h2&gt;虚表的大小&lt;/h2&gt;
&lt;p&gt;虚表的大小取决于类中虚函数的数量。每个虚函数占用一个指针大小的空间（通常是 4 或 8 字节，取决于平台）。&lt;/p&gt;
&lt;h2&gt;虚表的性能开销&lt;/h2&gt;
&lt;p&gt;虽然虚表引入了一定的性能开销（主要是通过 vptr 查找虚表的额外操作），但这种开销通常是可以接受的。虚表的查找时间是常数时间 (O(1))，因此虚函数的调用效率仍然很高。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的高级用法&lt;/h1&gt;
&lt;h2&gt;虚析构函数&lt;/h2&gt;
&lt;p&gt;虚析构函数是虚函数的一个重要应用。当通过基类指针删除派生类对象时，需要确保调用派生类的析构函数。通过将析构函数声明为虚函数，可以实现这一点。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual ~Base() { cout &amp;lt;&amp;lt; &quot;Base destructor&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    ~Derived() { cout &amp;lt;&amp;lt; &quot;Derived destructor&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr; // 输出 Derived destructor 和 Base destructor
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数与模板&lt;/h2&gt;
&lt;p&gt;虚函数和模板可以结合使用，但需要注意模板函数不能是虚函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

template &amp;lt;typename T&amp;gt;
void print(T* obj) {
    obj-&amp;gt;print();
}

int main() {
    Base* ptr = new Derived();
    print(ptr); // 输出 Derived::print()
    delete ptr;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;虚函数是 C++ 中实现多态的核心机制。通过虚函数，派生类可以重写基类的函数实现，从而实现动态绑定。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。虚函数的实现依赖于虚表（vtable）和虚指针（vptr）。&lt;/p&gt;
&lt;p&gt;纯虚函数和抽象类是虚函数的高级应用，它们允许我们定义接口类，确保派生类实现特定的函数。虚表是虚函数实现的基础，它存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;p&gt;理解虚函数和虚表的工作原理，有助于我们更好地掌握 C++ 的对象模型和性能优化。&lt;/p&gt;
</content:encoded></item><item><title>CMake：自动化构建的利器</title><link>https://loners.site/posts/cmake/</link><guid isPermaLink="true">https://loners.site/posts/cmake/</guid><description>`Makefile`跟系统的编译有很重要的相关，在不同的系统上`Makefile`编译出来的文件是不相同的，这时候对于我们跨平台解决问题有一个致命问题，好在我们有`CMake`来解决这一难题。</description><pubDate>Sat, 23 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;在现代软件开发中，构建系统是不可或缺的一部分。CMake 作为一种跨平台的自动化构建系统生成器，极大地简化了项目的编译和构建过程。与 Makefile 类似，CMake 通过编写配置文件（CMakeLists.txt）来定义项目的构建规则，但它的优势在于更高的可移植性和更强大的功能。CMake 可以生成多种构建系统，如 Makefile、Visual Studio 解决方案等，从而满足不同开发环境的需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
本课程笔记源自 &lt;a href=&quot;https://cmake.org/documentation/&quot;&gt;CMake 官方文档&lt;/a&gt; 和 &lt;a href=&quot;https://www.bilibili.com/video/BV1bg411p7oS/?&quot;&gt;CMake 教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CMake 涉及到 C++ 的多文件编译与运行，以下是一个简单的示例项目结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;project/
├── CMakeLists.txt
├── main.cpp
├── factorial.cpp
├── printhello.cpp
└── functions.h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中代码内容如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
using namespace std;

int main() {
    printhello();
    cout &amp;lt;&amp;lt; &quot;This is main:&quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;The factorial of 5 is: &quot; &amp;lt;&amp;lt; factorial(5) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;factorial.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;functions.h&quot;

int factorial(int n) {
    if (n == 1)
        return 1;
    else
        return n * factorial(n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printhello.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;

using namespace std;

void printhello() {
    cout &amp;lt;&amp;lt; &quot;Hello world&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;functions.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_

void printhello();
int factorial(int n);

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;法一（不使用 CMake）：&lt;/h1&gt;
&lt;p&gt;直接使用 &lt;code&gt;g++&lt;/code&gt; 编译项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
g++ main.cpp factorial.cpp printhello.cpp -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者手动编译每个源文件并链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.cpp -c
g++ factorial.cpp -c
g++ printhello.cpp -c
g++ *.o -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;法二（使用 CMake）：&lt;/h1&gt;
&lt;h2&gt;version1&lt;/h2&gt;
&lt;p&gt;创建一个简单的 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 1
# 设置 CMake 的最低版本要求
cmake_minimum_required(VERSION 3.0)

# 设置项目名称
project(MyProject)

# 添加可执行文件
add_executable(hello main.cpp printhello.cpp factorial.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 CMake：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
mkdir build
cd build
cmake ..
make
./hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version2&lt;/h2&gt;
&lt;p&gt;更灵活的 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 2
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤与 version1 相同。&lt;/p&gt;
&lt;h2&gt;version3&lt;/h2&gt;
&lt;p&gt;使用变量和更复杂的构建规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 3
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})

# 添加自定义目标
add_custom_target(run_hello COMMAND ./hello)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
mkdir build
cd build
cmake ..
make run_hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version4&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;target_include_directories&lt;/code&gt; 和 &lt;code&gt;target_link_libraries&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 4
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})

# 添加头文件目录
target_include_directories(hello PRIVATE ${CMAKE_SOURCE_DIR})

# 添加链接库（如果有）
# target_link_libraries(hello &amp;lt;library_name&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤与前面版本相同。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;CMake 提供了一种高效且灵活的方式来管理项目的构建过程。与手动编写 Makefile 或直接使用编译器命令相比，CMake 的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;：CMake 可以生成适用于不同操作系统的构建文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于维护&lt;/strong&gt;：通过 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件，可以清晰地定义项目的构建规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的功能&lt;/strong&gt;：支持复杂的项目结构、依赖管理和自定义目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实际项目中，使用 CMake 可以显著提高开发效率，减少重复劳动，并确保构建过程的一致性。&lt;/p&gt;
</content:encoded></item><item><title>Lambda 表达式与函数对象概述</title><link>https://loners.site/posts/cpp-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><guid isPermaLink="true">https://loners.site/posts/cpp-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>Lambda 表达式和函数对象是 C++11 引入的非常强大的特性，它们极大地简化了函数的定义和使用方式。就像一把多功能瑞士军刀，有了它们，我们可以在代码中更灵活地处理函数逻辑，无论是简单的回调函数，还是复杂的算法实现，都可以轻松应对。</description><pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Lambda 表达式和函数对象是 C++11 引入的非常强大的特性，它们极大地简化了函数的定义和使用方式。就像一把多功能瑞士军刀，有了它们，我们可以在代码中更灵活地处理函数逻辑，无论是简单的回调函数，还是复杂的算法实现，都可以轻松应对。接下来，让我们深入了解一下 Lambda 表达式和函数对象的奥秘。&lt;/p&gt;
&lt;h1&gt;Lambda 表达式(Lambda Expressions)&lt;/h1&gt;
&lt;p&gt;Lambda 表达式是一种匿名函数，它允许我们在代码中直接定义函数逻辑，而无需单独声明一个函数。Lambda 表达式的核心是对函数对象的封装，它提供了一种简洁的方式来实现函数式编程。&lt;/p&gt;
&lt;h2&gt;Lambda 表达式的语法&lt;/h2&gt;
&lt;p&gt;Lambda 表达式的基本语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[capture_list](parameters) -&amp;gt; return_type { body }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capture_list&lt;/strong&gt;：捕获列表，用于捕获外部变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parameters&lt;/strong&gt;：参数列表，与普通函数类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;return_type&lt;/strong&gt;：返回类型，可以省略，由编译器推导。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;body&lt;/strong&gt;：函数体，包含具体的逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lambda 表达式的使用&lt;/h2&gt;
&lt;p&gt;Lambda 表达式可以用于任何需要函数对象的场景，例如作为算法的参数、实现回调函数等。以下是一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};

    // 使用 Lambda 表达式作为回调函数
    std::for_each(v.begin(), v.end(), [](int x) {
        std::cout &amp;lt;&amp;lt; x * x &amp;lt;&amp;lt; &quot; &quot;;
    });

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Lambda 表达式的捕获机制&lt;/h2&gt;
&lt;p&gt;Lambda 表达式可以通过捕获列表捕获外部变量，捕获方式分为值捕获和引用捕获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;值捕获&lt;/strong&gt;：通过值捕获外部变量，捕获的变量在 Lambda 表达式中是副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用捕获&lt;/strong&gt;：通过引用捕获外部变量，捕获的变量在 Lambda 表达式中是引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int main() {
    int a = 10;
    int b = 20;

    // 值捕获
    auto lambda1 = [a, b]() {
        std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl; // 输出 30
    };

    // 引用捕获
    auto lambda2 = [&amp;amp;a, &amp;amp;b]() {
        std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl; // 输出 30
        a = 100; // 修改 a 的值
    };

    lambda1();
    lambda2();
    std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; // 输出 100

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;函数对象(Function Objects)&lt;/h1&gt;
&lt;p&gt;函数对象是一种重载了函数调用运算符&lt;code&gt;()&lt;/code&gt;的对象，它可以像函数一样被调用。函数对象比普通函数更灵活，因为它可以包含状态信息。&lt;/p&gt;
&lt;h2&gt;函数对象的定义&lt;/h2&gt;
&lt;p&gt;函数对象可以通过定义一个类并重载&lt;code&gt;()&lt;/code&gt;运算符来实现。以下是一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Adder {
public:
    Adder(int num) : num_(num) {} // 构造函数初始化状态

    int operator()(int x) const {
        return x + num_;
    }

private:
    int num_;
};

int main() {
    Adder add5(5);
    std::cout &amp;lt;&amp;lt; add5(10) &amp;lt;&amp;lt; std::endl; // 输出 15
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;函数对象的使用&lt;/h2&gt;
&lt;p&gt;函数对象可以用于需要函数指针或回调函数的场景。与 Lambda 表达式类似，函数对象也可以包含状态信息，因此在某些场景下比 Lambda 表达式更灵活。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};

    // 定义一个函数对象
    struct Square {
        void operator()(int x) const {
            std::cout &amp;lt;&amp;lt; x * x &amp;lt;&amp;lt; &quot; &quot;;
        }
    };

    // 使用函数对象作为回调函数
    std::for_each(v.begin(), v.end(), Square());

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Lambda 表达式与函数对象的比较&lt;/h1&gt;
&lt;p&gt;Lambda 表达式和函数对象都可以用于实现函数式编程，但它们有一些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;更简洁，适合快速定义简单的函数逻辑。&lt;/li&gt;
&lt;li&gt;语法灵活，支持捕获外部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数对象&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;更灵活，可以包含状态信息。&lt;/li&gt;
&lt;li&gt;可以通过类的成员函数实现更复杂的逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际使用中，可以根据具体需求选择合适的工具。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了一种简洁的方式来定义匿名函数。&lt;/li&gt;
&lt;li&gt;支持捕获外部变量，语法灵活。&lt;/li&gt;
&lt;li&gt;适用于简单的函数逻辑和回调函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重载&lt;code&gt;()&lt;/code&gt;运算符实现，可以包含状态信息。&lt;/li&gt;
&lt;li&gt;更灵活，适用于复杂的逻辑和需要状态的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择工具&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据具体需求选择 Lambda 表达式或函数对象。&lt;/li&gt;
&lt;li&gt;灵活运用它们可以提高代码的可读性和可维护性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>Makefile</title><link>https://loners.site/posts/makefile/</link><guid isPermaLink="true">https://loners.site/posts/makefile/</guid><description>Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个Make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，Makefile都成为了一种在工程方面的编译方法。</description><pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个Make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，Makefile都成为了一种在工程方面的编译方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
本课程笔记源自&lt;a href=&quot;https://www.bilibili.com/video/BV188411L7d2&quot;&gt;Makefile&lt;/a&gt;,以及&lt;a href=&quot;https://www.bilibili.com/video/BV1bg411p7oS/?&quot;&gt;CMake&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Makefile涉及到cpp的多文件同时编译与运行，我们在编译一下代码的时候会涉及到：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
using namespace std;
 
int main()
{
    printhello();
    cout &amp;lt;&amp;lt; &quot;This is main:&quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;The factorial of 5 is: &quot; &amp;lt;&amp;lt; factorial(5) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;factorial.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;functions.h&quot;
 
int factorial(int n)
{
    if(n == 1)
            return 1;
    else
            return n * factorial(n-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printhello.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
 
using namespace std;
 
void printhello()
{
    int i;
    cout &amp;lt;&amp;lt; &quot;Hello world&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;function.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_
void printhello();
int factorial(int n);
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;法一(不使用makefile)：&lt;/h1&gt;
&lt;p&gt;进入learn_makefile生成可执行程序文件&lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd learn_makefile
g++ main.cpp factorial.cpp printhello.cpp -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;逐个&lt;strong&gt;编译&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.cpp -c
g++ factorial.cpp -c
g++ helloprint.cpp -c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再进行&lt;strong&gt;链接&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ *.o -o main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再用&lt;code&gt;g++&lt;/code&gt;来运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;一般我们用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm *.o
rm main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除&lt;code&gt;.o&lt;/code&gt;文件和&lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;法二(创建Makefile文件):&lt;/h1&gt;
&lt;h2&gt;verison1&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 1
# hello为生成的可执行文件，依赖于后面的三个.cpp文件
# g++前面加一个TAB的空格
hello: main.cpp printhello.cpp factorial.cpp
	g++ -o hello main.cpp printhello.cpp factorial.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cd learn_makefile
make
./hellop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点:文件多时，编译时间长&lt;/p&gt;
&lt;h2&gt;version2&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;文件有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 2
CXX = g++
TARGET = hello
OBJ = main.o printhello.o factorial.o
# make时执行g++ 先找TARGET，TARGET不存在找OBJ，OBJ不存在，编译三个.cpp文件生成.o文件
# 然后再编译OBJ文件，生成可执行文件hello
$(TARGET): $(OBJ)
	$(CXX) -o $(TARGET) $(OBJ)
# main.o这样来的，编译main.cpp生成
main.o: main.cpp
	$(CXX) -c main.cpp
printhello.o: printhello.cpp
	$(CXX) -c printhello.cpp
factorial.o: factorial.cpp
	$(CXX) -c factorial.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version3&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 3
CXX = g++
TARGET = hello
OBJ = main.o printhello.o factorial.o
 
# 编译选项，显示所有的warning
CXXLAGS = -c -Wall
 
# $@表示的就是冒号前面的TARGET，$^表示的是冒号后OBJ的全部.o依赖文件
$(TARGET): $(OBJ)
	$(CXX) -o $@ $^
 
# $&amp;lt;表示指向%.cpp依赖的第一个，但是这里依赖只有一个
# $@表示指向%.o
%.o: %.cpp
	$(CXX) $(CXXLAGS) $&amp;lt; -o $@
 
# 为了防止文件夹中存在一个文件叫clean
.PHONY: clean
 
# -f表示强制删除，此处表示删除所有的.o文件和TARGET文件
clean:
	rm -f *.o $(TARGET)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version4&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 4
CXX = g++
TARGET = hello
# 所有当前目录的.cpp文件都放在SRC里面
SRC = $(wildcard *.cpp)
# 把SRC里面的.cpp文件替换为.o文件
OBJ = $(patsubst %.cpp, %.o,$(SRC))
 
CXXLAGS = -c -Wall
 
$(TARGET): $(OBJ)
	$(CXX) -o $@ $^
 
%.o: %.cpp
	$(CXX) $(CXXLAGS) $&amp;lt; -o $@
 
.PHONY: clean
clean:
	rm -f *.o $(TARGET)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;写项目的时候我们如果采用&lt;code&gt;Makefile&lt;/code&gt;方法，我们的脚本仅仅需要写一次，而用gcc命令的话，我们每次都需要重新写一遍。&lt;/p&gt;
</content:encoded></item><item><title>重载函数</title><link>https://loners.site/posts/cpp-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://loners.site/posts/cpp-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</guid><description>`Cpp` 的重载函数是依据于 `Argument-dependent lookup`（也称作 ADL），也就是说，即使有相同的函数名，但是我们也依据参数列表的不同来调用，这涉及到编译原理。我们知道，利用 `.cpp` 文件可以编译成 `.obj` 文件，再通过链接器链接变成 `.exe` 文件，而 `Cpp` 的重载特性就是从编译器下手的。</description><pubDate>Thu, 21 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;我们为什么要重载？搞清楚这个问题我们要回顾到 &lt;code&gt;C&lt;/code&gt; 中，&lt;code&gt;C99&lt;/code&gt; 中有一个 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 头文件，里面定义了不同的四舍五入方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;roundf&lt;/td&gt;
&lt;td&gt;(float x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;roundl&lt;/td&gt;
&lt;td&gt;(long double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们发现不同的数据类型有不同的函数名，而其效果都是达到一个四舍五入的效果，但是，这种函数名加重了我们的记忆负担，不利于我们去记忆。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cpp&lt;/code&gt; 提供了一个函数重载的功能，这个功能可以方便我们记忆函数。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;C++11&lt;/code&gt; 的 &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; 为例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(float x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(long double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;重载函数如何实现？&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Cpp&lt;/code&gt; 的重载函数是依据于 &lt;code&gt;Argument-dependent lookup&lt;/code&gt;（也称作 ADL），也就是说，即使有相同的函数名，但是我们也依据参数列表的不同来调用，这涉及到编译原理。我们知道，利用 &lt;code&gt;.cpp&lt;/code&gt; 文件可以编译成 &lt;code&gt;.obj&lt;/code&gt; 文件，再通过链接器链接变成 &lt;code&gt;.exe&lt;/code&gt; 文件，而 &lt;code&gt;Cpp&lt;/code&gt; 的重载特性就是从编译器下手的。&lt;/p&gt;
&lt;p&gt;我们可以自定义多个 &lt;code&gt;max()&lt;/code&gt; 函数，通过打印来确定我们采用的是哪一个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int max(int x, int y) {
    cout &amp;lt;&amp;lt; &quot;max(int,int) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

float max(float x, float y) {
    cout &amp;lt;&amp;lt; &quot;max(float,float) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

double max(double x, double y) {
    cout &amp;lt;&amp;lt; &quot;max(double,double) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

int main() {
    cout &amp;lt;&amp;lt; max(3, 5) &amp;lt;&amp;lt; endl;       // 调用 int 版本
    cout &amp;lt;&amp;lt; max(3.5f, 5.2f) &amp;lt;&amp;lt; endl; // 调用 float 版本
    cout &amp;lt;&amp;lt; max(3.5, 5.2) &amp;lt;&amp;lt; endl;   // 调用 double 版本
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;防止歧义&lt;/h1&gt;
&lt;p&gt;在使用重载函数时，需要注意防止歧义。如果编译器无法根据参数类型唯一确定调用的函数版本，就会导致编译错误。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x) {
    cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl;
}

void print(double x) {
    cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl;
}

int main() {
    print(5);    // 明确调用 print(int)
    print(5.0);  // 明确调用 print(double)
    print(5.0f); // 错误！无法确定是调用 print(int) 还是 print(double)
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了避免歧义，需要确保重载函数的参数类型之间有足够的区分度，或者通过显式类型转换来明确指定调用的版本。&lt;/p&gt;
&lt;h1&gt;重载的规则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数数量不同&lt;/strong&gt;：可以通过参数数量的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print() { cout &amp;lt;&amp;lt; &quot;No arguments&quot; &amp;lt;&amp;lt; endl; }
void print(int x) { cout &amp;lt;&amp;lt; &quot;One int argument&quot; &amp;lt;&amp;lt; endl; }
void print(int x, int y) { cout &amp;lt;&amp;lt; &quot;Two int arguments&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数类型不同&lt;/strong&gt;：可以通过参数类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(double x) { cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数类型顺序不同&lt;/strong&gt;：可以通过参数类型的顺序不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x, double y) { cout &amp;lt;&amp;lt; &quot;print(int, double)&quot; &amp;lt;&amp;lt; endl; }
void print(double x, int y) { cout &amp;lt;&amp;lt; &quot;print(double, int)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用类型不同&lt;/strong&gt;：可以通过引用类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int &amp;amp;x) { cout &amp;lt;&amp;lt; &quot;print(int &amp;amp;)&quot; &amp;lt;&amp;lt; endl; }
void print(const int &amp;amp;x) { cout &amp;lt;&amp;lt; &quot;print(const int &amp;amp;)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;重载的限制&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回值类型不能用于重载&lt;/strong&gt;：不能仅通过返回值类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int add(int x, int y) { return x + y; }
double add(int x, int y) { return x + y; } // 错误！无法通过返回值类型重载
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数默认值不能用于重载&lt;/strong&gt;：不能仅通过参数默认值的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x = 0) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(int x = 0, int y = 0) { cout &amp;lt;&amp;lt; &quot;print(int, int)&quot; &amp;lt;&amp;lt; endl; } // 错误！无法通过默认值重载
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;构造函数重载&lt;/h1&gt;
&lt;p&gt;构造函数也可以重载，通过不同的参数列表来实现对象的初始化。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Point {
public:
    Point() : x(0), y(0) { cout &amp;lt;&amp;lt; &quot;Default constructor&quot; &amp;lt;&amp;lt; endl; }
    Point(int x, int y) : x(x), y(y) { cout &amp;lt;&amp;lt; &quot;Constructor with two ints&quot; &amp;lt;&amp;lt; endl; }
    Point(double x, double y) : x(x), y(y) { cout &amp;lt;&amp;lt; &quot;Constructor with two doubles&quot; &amp;lt;&amp;lt; endl; }

private:
    int x, y;
};

int main() {
    Point p1;                 // 调用默认构造函数
    Point p2(3, 4);           // 调用 int 版本构造函数
    Point p3(3.5, 4.2);       // 调用 double 版本构造函数
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;重载与模板&lt;/h1&gt;
&lt;p&gt;模板函数也可以参与重载。模板函数的实例化是根据模板参数的类型来确定的，因此模板函数可以与普通函数或模板函数重载。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;typename T&amp;gt;
void print(T x) {
    cout &amp;lt;&amp;lt; &quot;Template print(T)&quot; &amp;lt;&amp;lt; endl;
}

void print(int x) {
    cout &amp;lt;&amp;lt; &quot;Non-template print(int)&quot; &amp;lt;&amp;lt; endl;
}

int main() {
    print(5);    // 调用非模板版本
    print(5.0);  // 调用模板版本
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;函数重载是 C++ 提供的一种强大的功能，它允许我们使用相同的函数名来实现不同的功能。通过参数数量、参数类型、参数顺序等的不同，可以实现函数的重载。在使用重载函数时，需要注意避免歧义，并遵循重载的规则。合理使用重载可以提高代码的可读性和可维护性。&lt;/p&gt;
</content:encoded></item></channel></rss>