<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MonX</title><description>罗德岛</description><link>https://loners.site/</link><language>zh_CN</language><item><title>Vue 3.0 快速上手教程</title><link>https://loners.site/posts/vue30/</link><guid isPermaLink="true">https://loners.site/posts/vue30/</guid><description>Vue 3 是 Vue.js 的最新版本，它带来了性能提升、更好的 TypeScript 支持以及新的 Composition API 等特性。本教程是基于 Vue 3 的快速上手教程，帮助你快速掌握其核心语法和功能。</description><pubDate>Wed, 26 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
本教程假设你已经具备基本的 JavaScript 和 HTML 知识。&lt;/p&gt;
&lt;p&gt;你可以通过 &lt;a href=&quot;https://v3.vuejs.org/guide/introduction.html&quot;&gt;Vue.js 官方文档&lt;/a&gt;了解更多关于 Vue 3 的详细信息。&lt;/p&gt;
&lt;p&gt;本笔记基于课程&lt;a href=&quot;https://www.bilibili.com/video/BV1Pg4y1A7pn&quot;&gt;半小时入门Vue3.0核心语法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;环境准备&lt;/h1&gt;
&lt;p&gt;在开始之前，确保你的开发环境已经安装了 Node.js 和 npm。你可以通过以下命令安装 Vue CLI：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，可以通过以下命令创建一个新的 Vue 3 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue create my-vue3-project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在创建过程中，确保选择 Vue 3 作为项目版本。&lt;/p&gt;
&lt;h1&gt;Vue 3 基础语法&lt;/h1&gt;
&lt;h2&gt;2.1 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Vue 3 引入了 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; 语法，它是一种更简洁的组件编写方式，适用于组合式 API。以下是一个简单的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- HelloWorld.vue --&amp;gt;
&amp;lt;script setup&amp;gt;
import { reactive, ref, computed, watch, watchEffect } from &apos;vue&apos;

// 定义响应式数据
const count = ref(0)
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

// 定义计算属性
const getLen = computed(() =&amp;gt; {
  console.log(&apos;INVOKE computed&apos;)
  return myData.friends.length
})

// 定义侦听器
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 定义自动侦听
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})

// 定义事件处理函数
function clickHandler() {
  count.value++
  myData.age++
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;greetings&quot;&amp;gt;
    &amp;lt;h1 class=&quot;green&quot;&amp;gt;{{ getLen }}&amp;lt;/h1&amp;gt;
    &amp;lt;button @click=&quot;clickHandler&quot;&amp;gt;增加&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
h1 {
  font-weight: 500;
  font-size: 2.6rem;
  position: relative;
  top: -10px;
}

button {
  margin-top: 20px;
  padding: 10px 20px;
  font-size: 16px;
}

.greetings h1,
.greetings h3 {
  text-align: center;
}

@media (min-width: 1024px) {
  .greetings h1,
  .greetings h3 {
    text-align: left;
  }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.2 响应式数据&lt;/h2&gt;
&lt;p&gt;Vue 3 使用 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;reactive&lt;/code&gt; 来定义响应式数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt; 用于定义基本数据类型的响应式数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reactive&lt;/code&gt; 用于定义对象类型的响应式数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, reactive } from &apos;vue&apos;

const count = ref(0) // 基本数据类型
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
}) // 对象类型
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3 计算属性&lt;/h2&gt;
&lt;p&gt;计算属性是基于依赖的缓存属性。当依赖的响应式数据发生变化时，计算属性会自动重新计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, computed } from &apos;vue&apos;

const content = ref(&apos;hello world&apos;)
const getLen = computed(() =&amp;gt; {
  return content.value.length
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.4 侦听器&lt;/h2&gt;
&lt;p&gt;侦听器用于监听数据的变化，并执行特定的操作。Vue 3 提供了 &lt;code&gt;watch&lt;/code&gt; 和 &lt;code&gt;watchEffect&lt;/code&gt; 两种侦听器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;watch&lt;/code&gt; 用于监听特定数据的变化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;watchEffect&lt;/code&gt; 用于自动侦听所有依赖的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, watch, watchEffect } from &apos;vue&apos;

const count = ref(0)
const myData = reactive({
  age: 21
})

// 监听特定数据的变化
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 自动侦听所有依赖的变化
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.5 浅响应式与只读数据&lt;/h2&gt;
&lt;p&gt;Vue 3 提供了 &lt;code&gt;shallowReactive&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 用于定义浅响应式数据和只读数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shallowReactive&lt;/code&gt; 用于定义浅响应式数据，只有外层数据是响应式的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly&lt;/code&gt; 用于定义只读数据，数据不能被修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { shallowReactive, readonly } from &apos;vue&apos;

const myData = shallowReactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

const myReadOnlyData = readonly({
  name: &apos;cmx&apos;,
  age: 21
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;组合式 API&lt;/h1&gt;
&lt;p&gt;组合式 API 是 Vue 3 的核心特性之一，它允许你将逻辑相关的代码组织在一起，提高代码的可维护性和可重用性。&lt;/p&gt;
&lt;h2&gt;3.1 使用 &lt;code&gt;setup&lt;/code&gt; 函数&lt;/h2&gt;
&lt;p&gt;在 Vue 3 中，&lt;code&gt;setup&lt;/code&gt; 函数是组合式 API 的入口点。你可以在 &lt;code&gt;setup&lt;/code&gt; 函数中定义响应式数据、生命周期钩子、计算属性等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { ref, computed } from &apos;vue&apos;

export default {
  setup() {
    const count = ref(0)
    const doubleCount = computed(() =&amp;gt; count.value * 2)

    return {
      count,
      doubleCount
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.2 自定义组合函数&lt;/h2&gt;
&lt;p&gt;自定义组合函数是一种将逻辑相关的代码封装在一起的方式，可以提高代码的可重用性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, computed } from &apos;vue&apos;

function useCounter() {
  const count = ref(0)
  const doubleCount = computed(() =&amp;gt; count.value * 2)
  const increment = () =&amp;gt; count.value++

  return { count, doubleCount, increment }
}

const { count, doubleCount, increment } = useCounter()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;TypeScript 支持&lt;/h1&gt;
&lt;p&gt;Vue 3 提供了更好的 TypeScript 支持，你可以通过定义类型来提高代码的可维护性和可读性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref } from &apos;vue&apos;

const count = ref&amp;lt;number&amp;gt;(0)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;示例代码&lt;/h1&gt;
&lt;p&gt;以下是完整的示例代码，展示了上述功能的综合应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- HelloWorld.vue --&amp;gt;
&amp;lt;script setup&amp;gt;
import { reactive, ref, computed, watch, watchEffect } from &apos;vue&apos;

// 定义响应式数据
const count = ref(0)
const myData = reactive({
  name: &apos;cmx&apos;,
  age: 21,
  friends: [&apos;8ks&apos;, &apos;cyy&apos;]
})

// 定义计算属性
const getLen = computed(() =&amp;gt; {
  console.log(&apos;INVOKE computed&apos;)
  return myData.friends.length
})

// 定义侦听器
watch(() =&amp;gt; myData.age, (newVal, oldVal) =&amp;gt; {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

// 定义自动侦听
watchEffect(() =&amp;gt; {
  console.log(`count的值为: ${count.value}, myData的值为: ${myData.age}`)
})

// 定义事件处理函数
function clickHandler() {
  count.value++
  myData.age++
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;greetings&quot;&amp;gt;
    &amp;lt;h1 class=&quot;green&quot;&amp;gt;{{ getLen }}&amp;lt;/h1&amp;gt;
    &amp;lt;button @click=&quot;clickHandler&quot;&amp;gt;增加&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
h1 {
  font-weight: 500;
  font-size: 2.6rem;
  position: relative;
  top: -10px;
}

button {
  margin-top: 20px;
  padding: 10px 20px;
  font-size: 16px;
}

.greetings h1,
.greetings h3 {
  text-align: center;
}

@media (min-width: 1024px) {
  .greetings h1,
  .greetings h3 {
    text-align: left;
  }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;通过以上内容，你已经掌握了 Vue 3 的基本语法和功能，包括 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;、响应式数据、计算属性、侦听器和组合式 API。这些功能将帮助你快速构建动态的用户界面。接下来，你可以通过阅读官方文档和实践更多项目，进一步提升你的 Vue.js 技能。&lt;/p&gt;
</content:encoded></item><item><title>Vue 2.0 快速上手教程</title><link>https://loners.site/posts/vue20/</link><guid isPermaLink="true">https://loners.site/posts/vue20/</guid><description>Vue.js 是一个用于构建用户界面的渐进式框架，它通过声明式的数据绑定和组件系统，简化了 DOM 操作和页面渲染。本教程将帮助你快速上手 Vue 2.0，并了解其基本概念和用法。</description><pubDate>Tue, 25 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;本教程假设你已经具备基本的 HTML、CSS 和 JavaScript 知识。如果你对这些知识不熟悉，可以先学习相关的教程。&lt;/p&gt;
&lt;p&gt;本笔记基于Bilibili课程&lt;a href=&quot;https://www.bilibili.com/video/BV1oj411D7jk&quot;&gt;30分钟学会Vue之核心语法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;环境准备&lt;/h1&gt;
&lt;p&gt;在开始之前，确保你的开发环境已经安装了 Node.js 和 npm。你可以通过以下命令安装 Vue CLI：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，可以通过以下命令创建一个新的 Vue 项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue create my-vue-project
cd my-vue-project
npm run serve
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Vue 2.0 基础语法&lt;/h1&gt;
&lt;h2&gt;2.1 响应式数据与插值表达式&lt;/h2&gt;
&lt;p&gt;Vue 的核心特性之一是响应式数据绑定。通过在模板中使用插值表达式（&lt;code&gt;{{ }}&lt;/code&gt;），可以将数据动态绑定到 DOM 中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ title }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;{{ content }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 JavaScript 中，通过 Vue 实例的 &lt;code&gt;data&lt;/code&gt; 属性定义响应式数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;data&lt;/code&gt; 中的数据发生变化时，页面上绑定的内容会自动更新。&lt;/p&gt;
&lt;h2&gt;2.2 方法与插值表达式&lt;/h2&gt;
&lt;p&gt;Vue 允许在模板中调用方法。通过在 &lt;code&gt;methods&lt;/code&gt; 中定义函数，可以在插值表达式中使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ output() }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    },
    methods: {
        output() {
            return `Title: ${this.title}, Content: ${this.content}`;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.3 计算属性&lt;/h2&gt;
&lt;p&gt;计算属性是基于依赖的缓存属性。当依赖的响应式数据发生变化时，计算属性会自动重新计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ outputContent }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义计算属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;,
        content: &apos;This is a Vue.js project.&apos;
    },
    computed: {
        outputContent() {
            return `Title: ${this.title}, Content: ${this.content}`;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.4 侦听器（Watchers）&lt;/h2&gt;
&lt;p&gt;侦听器用于监听数据的变化，并执行特定的操作。通过在 &lt;code&gt;watch&lt;/code&gt; 中定义侦听器，可以实现更复杂的逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Hello Vue!&apos;
    },
    watch: {
        title(newVal, oldVal) {
            console.log(`Title changed from ${oldVal} to ${newVal}`);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;指令&lt;/h1&gt;
&lt;p&gt;Vue 提供了一系列指令，用于操作 DOM 和绑定数据。&lt;/p&gt;
&lt;h2&gt;3.1 条件渲染&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; 用于根据条件渲染元素。&lt;code&gt;v-if&lt;/code&gt; 是真正的条件渲染，而 &lt;code&gt;v-show&lt;/code&gt; 只是切换元素的 CSS 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-if=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
    &amp;lt;p v-show=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义布尔值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        bool: true
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.2 列表渲染&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-for&lt;/code&gt; 用于渲染列表数据。可以通过数组或对象进行循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-for=&quot;item in arr&quot;&amp;gt;{{ item }}&amp;lt;/p&amp;gt;
    &amp;lt;p v-for=&quot;(item, key, index) in obj&quot;&amp;gt;{{ item }} - {{ key }} - {{ index }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义数组和对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],
        obj: { a: 10, b: 20, c: 30 }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.3 属性绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-bind&lt;/code&gt; 用于动态绑定 DOM 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p v-bind:title=&quot;title&quot;&amp;gt;Hover over me to see the title.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义属性值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        title: &apos;Dynamic Title&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.4 事件绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-on&lt;/code&gt; 或简写为 &lt;code&gt;@&lt;/code&gt; 用于绑定事件处理器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;button @click=&quot;output&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义事件处理方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    methods: {
        output() {
            alert(&apos;Button clicked!&apos;);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.5 表单绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 用于实现双向数据绑定，将表单输入与数据绑定在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ inputValue }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义绑定的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        inputValue: &apos;Default Value&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;修饰符&lt;/h1&gt;
&lt;p&gt;Vue 提供了一些修饰符，用于增强指令的功能。&lt;/p&gt;
&lt;h2&gt;4.1 事件修饰符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt; 修饰符用于去除输入值的首尾空格。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; v-model.trim=&quot;inputValue&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Vue 实例中定义绑定的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// main.js
new Vue({
    el: &apos;#app&apos;,
    data: {
        inputValue: &apos;&apos;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;示例代码&lt;/h1&gt;
&lt;p&gt;以下是完整的示例代码，展示了上述功能的综合应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;Vue 2.0 Quick Start&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;{{ content }}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;{{ outputContent }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-if=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
        &amp;lt;p v-show=&quot;bool&quot;&amp;gt;This is visible when bool is true.&amp;lt;/p&amp;gt;
        &amp;lt;p v-for=&quot;item in arr&quot;&amp;gt;{{ item }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-for=&quot;(item, key, index) in obj&quot;&amp;gt;{{ item }} - {{ key }} - {{ index }}&amp;lt;/p&amp;gt;
        &amp;lt;p v-bind:title=&quot;title&quot;&amp;gt;Hover over me to see the title.&amp;lt;/p&amp;gt;
        &amp;lt;button @click=&quot;output&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
        &amp;lt;input type=&quot;text&quot; v-model.trim=&quot;inputValue&quot;&amp;gt;
        &amp;lt;p&amp;gt;{{ inputValue }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        new Vue({
            el: &apos;#app&apos;,
            data: {
                title: &apos;Hello Vue!&apos;,
                content: &apos;This is a Vue.js project.&apos;,
                bool: true,
                arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],
                obj: { a: 10, b: 20, c: 30 },
                inputValue: &apos;Default Value&apos;
            },
            methods: {
                output() {
                    alert(&apos;Button clicked!&apos;);
                }
            },
            computed: {
                outputContent() {
                    return `Title: ${this.title}, Content: ${this.content}`;
                }
            },
            watch: {
                title(newVal, oldVal) {
                    console.log(`Title changed from ${oldVal} to ${newVal}`);
                }
            }
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;通过以上内容，你已经掌握了 Vue 2.0 的基本语法和功能，包括响应式数据、插值表达式、指令、计算属性、侦听器和修饰符。这些功能将帮助你快速构建动态的用户界面。接下来，你可以通过阅读官方文档和实践更多项目，进一步提升你的 Vue.js 技能。&lt;/p&gt;
</content:encoded></item><item><title>CS205 Lab01</title><link>https://loners.site/posts/cs205-lab01/</link><guid isPermaLink="true">https://loners.site/posts/cs205-lab01/</guid><description>Welcome to my CS205 lecture notes!</description><pubDate>Tue, 18 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;Welcome to my CS205 lecture notes! Because the lecture is not in English, I will try my best to translate it.
And at the same time, the &lt;code&gt;PPT&lt;/code&gt;,&lt;code&gt;lab-file&lt;/code&gt; also use the English,I will write &lt;strong&gt;the English notes but not all.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
If you have a passion to konw more about the course, you can click the link below to learn more about the course.
Read the repo.&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;MongxinChan/CPP&quot;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Lab 1&lt;/h1&gt;
&lt;h2&gt;Task 1 Install WSL&lt;/h2&gt;
&lt;p&gt;install wsl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this task,I fail to install wsl.
So I do this :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl -l -o
wsl --install -d Ubuntu-20.04
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C1.png&quot; alt=&quot;image-20250318003050449&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s my successful examples.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DISM.exe /Online /Enable-Feature /FeatureName:VirtualMachinePlatform /All /NoRestart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C2.png&quot; alt=&quot;image-20250318003517641&quot; /&gt;&lt;/p&gt;
&lt;p&gt;use the &lt;code&gt;bash&lt;/code&gt; to start the system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wsl -l -v
wsl -d Ubuntu-24.04
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the username and password is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I donnot update in the markdown = =
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C3.png&quot; alt=&quot;image-20250318004410701&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C4.png&quot; alt=&quot;4png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;we see that the &lt;code&gt;Ubuntu-24.04&lt;/code&gt; has been installed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C5.png&quot; alt=&quot;image-20250318004758417&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install g++ -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we use the commond to check their version up&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C6.png&quot; alt=&quot;image-20250318090019674&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task 2 Use the WSL in visual studio code&lt;/h2&gt;
&lt;p&gt;Open the &lt;code&gt;vscode&lt;/code&gt;(Downloaded)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C7.png&quot; alt=&quot;7png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;O&lt;/code&gt; to command the system, and wait for a while to install the server of WSL&lt;/p&gt;
&lt;p&gt;If the connection is successful you will see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C8.png&quot; alt=&quot;8png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5C9.png&quot; alt=&quot;9png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/mnt/d/Code/Cplusplus/SUST Cpp course/&lt;/code&gt; is a file path, typically used in a &lt;code&gt;Linux&lt;/code&gt; system to indicate a directory within a mounted Windows file system. Here’s a breakdown of its components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;/mnt/d&lt;/code&gt;&lt;/strong&gt;: In Linux, &lt;code&gt;/mnt&lt;/code&gt; is a mount point directory commonly used for mounting external storage devices or partitions. &lt;code&gt;/mnt/d&lt;/code&gt; indicates that the D drive from a Windows system is mounted here.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Task 3 Compile,Link and Run C/C++ Programs&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileProcession.png&quot; alt=&quot;image-20250404170927050&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileFileStep.png&quot; alt=&quot;image-20250404171355890&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The step called &lt;code&gt;Compile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileFileStep2.png&quot; alt=&quot;image-20250404171509663&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We create  the &lt;code&gt;.exe&lt;/code&gt; post-name-file. The step called &lt;code&gt;Linking&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileFileStep3.png&quot; alt=&quot;image-20250404171802256&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The default output executable file is called “a.exe”(Windows) or “a.out”(Unix  and Mac OS) if you don’t specify the name in compiling and linking step.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileFileStep4.png&quot; alt=&quot;image-20250404171945336&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You need to use &lt;code&gt;g++&lt;/code&gt; to compile C++ program. The &lt;code&gt;-o&lt;/code&gt; option is used to &lt;code&gt;specify the output file name&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileFileStep5.png&quot; alt=&quot;image-20250404172756641&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task# 4Terminal Output&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;printf&lt;/strong&gt;(format-control-string, other-arguments) f&lt;strong&gt;ormat-control-string&lt;/strong&gt; describes the output format, which consists of conversion specifiers, field  widths, precisions and literal characters with percent sign(%).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CPicture.png&quot; alt=&quot;Picture&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Task# 5 Execrise&lt;/h2&gt;
&lt;p&gt;We couldnot directly compile the &lt;code&gt;main.cpp&lt;/code&gt; if we only compile the &lt;code&gt;main.cpp&lt;/code&gt; advoke &lt;code&gt;g++ -o main main.cpp &amp;amp;&amp;amp; ./main&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5CcompileError.png&quot; alt=&quot;image-20250404173852592&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译 &lt;code&gt;add.cpp&lt;/code&gt; 文件生成对象文件&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ -c add.cpp -o add.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译 &lt;code&gt;main.cpp&lt;/code&gt; 文件生成对象文件&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ -c main.cpp -o main.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接两个对象文件生成可执行文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.o add.o -o myprogram.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;gcc -c add.cpp -o add.o
gcc -c main.cpp -o main.o
gcc main.o add.o -o myprogram -lstdc++
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cmake&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;步骤 1: 创建 CMakeLists.txt 文件&lt;/p&gt;
&lt;p&gt;在你的项目根目录下创建一个名为 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 的文件。这个文件将包含构建项目的指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.10)

# 项目名称
project(MyProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加源文件
add_executable(myprogram main.cpp add.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 2: 创建构建目录&lt;/p&gt;
&lt;p&gt;在项目根目录下创建一个名为 &lt;code&gt;build&lt;/code&gt; 的目录，用于存放构建文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir build
cd build
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 3: 运行 CMake&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;build&lt;/code&gt; 目录中运行 &lt;code&gt;cmake&lt;/code&gt; 命令，指定源代码目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会读取 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件，并生成适合你的系统的构建文件（如 Makefile 或 Visual Studio 解决方案文件）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤 4: 编译项目&lt;/p&gt;
&lt;p&gt;使用生成的构建文件编译项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你使用的是 Makefile（通常是在 Unix-like 系统上）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你使用的是 Visual Studio（在 Windows 上）：&lt;/p&gt;
&lt;p&gt;打开生成的解决方案文件，并在 Visual Studio 中构建项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;.%5Cpic%5Ccompleted.png&quot; alt=&quot;completed&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>CS61B Lecture 1</title><link>https://loners.site/posts/cs61b-lecture1/</link><guid isPermaLink="true">https://loners.site/posts/cs61b-lecture1/</guid><description>Welcome to my CS61B lecture notes!</description><pubDate>Sun, 01 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;Welcome to my CS61B lecture notes!
In this notice, I will be sharing my notes and resources related to &lt;a href=&quot;https://sp24.datastructur.es/&quot;&gt;the course&lt;/a&gt; &lt;code&gt;CS61B: Data Structures&lt;/code&gt; taught by Justin Yokota and Peyrin Kao .
I will be posting my lecture notes, assignments, and other materials that I have completed during the course. I hope that these notes will be helpful to others who are taking the course. If you have any questions or feedback, please feel free to contact me. Thank you for your attention.&lt;/p&gt;
&lt;p&gt;If you wanna read the Chinese Edition,&lt;a href=&quot;#&quot;&gt;Click Here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>虚函数：C++ 多态的核心</title><link>https://loners.site/posts/cpp-%E8%99%9A%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://loners.site/posts/cpp-%E8%99%9A%E5%87%BD%E6%95%B0/</guid><description>在面向对象编程中，多态是一种强大的特性，它允许我们通过基类的接口调用派生类的实现。C++ 中的虚函数（Virtual Function）是实现多态的关键机制。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。重载函数主要用于编译时的多态（静态绑定），而虚函数则用于运行时的多态（动态绑定）。</description><pubDate>Sat, 23 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;在面向对象编程中，多态是一种强大的特性，它允许我们通过基类的接口调用派生类的实现。C++ 中的虚函数（Virtual Function）是实现多态的关键机制。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。重载函数主要用于编译时的多态（静态绑定），而虚函数则用于运行时的多态（动态绑定）。&lt;/p&gt;
&lt;p&gt;虚函数的实现依赖于一个隐藏的数据结构——虚表（Virtual Table，简称 vtable）。虚表是一个函数指针数组，存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;p&gt;理解虚函数和虚表的工作原理，对于深入掌握 C++ 的对象模型和性能优化至关重要。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的设计理念&lt;/h1&gt;
&lt;p&gt;虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重载函数（Overloading）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：通过相同的函数名和不同的参数列表，提供多种函数实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：编译时多态（静态绑定）。编译器根据函数的参数类型和数量选择正确的函数版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;void print(int x) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(double x) { cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;虚函数（Virtual Function）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：通过基类的接口调用派生类的实现，实现运行时多态（动态绑定）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：运行时多态。通过虚表（vtable）和虚指针（vptr）动态选择正确的函数版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚函数的设计理念是为了解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在运行时动态选择函数的实现？&lt;/li&gt;
&lt;li&gt;如何通过基类的指针或引用调用派生类的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的定义与使用&lt;/h1&gt;
&lt;h2&gt;虚函数的定义&lt;/h2&gt;
&lt;p&gt;虚函数通过在函数声明前加上 &lt;code&gt;virtual&lt;/code&gt; 关键字来定义。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚函数的声明表示该函数可以在派生类中被重写（override）。如果派生类没有重写虚函数，则会继承基类的实现。&lt;/p&gt;
&lt;h2&gt;虚函数的使用&lt;/h2&gt;
&lt;p&gt;虚函数的使用依赖于基类的指针或引用。通过基类的指针或引用调用虚函数时，实际调用的是派生类的实现（如果派生类重写了该虚函数）。这种机制称为动态绑定（Dynamic Binding）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    Base* ptr = new Derived();
    ptr-&amp;gt;print(); // 输出 Derived::print()
    delete ptr;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数的继承&lt;/h2&gt;
&lt;p&gt;当派生类继承自基类时，派生类会继承基类的虚函数。如果派生类重写了基类的虚函数，虚表中的相应条目会被更新为派生类的函数地址。如果派生类没有重写某些虚函数，虚表中的条目则保持基类的函数地址。&lt;/p&gt;
&lt;h2&gt;虚函数的覆盖（Override）&lt;/h2&gt;
&lt;p&gt;派生类可以通过重写基类的虚函数来覆盖其行为。使用 &lt;code&gt;override&lt;/code&gt; 关键字可以显式地表示覆盖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数的隐藏（Hide）&lt;/h2&gt;
&lt;p&gt;如果派生类定义了一个与基类虚函数同名但参数列表不同的函数，这将隐藏基类的虚函数，而不是覆盖它。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print(int x) { cout &amp;lt;&amp;lt; &quot;Base::print(int)&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; } // 隐藏了 Base::print(int)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;纯虚函数与抽象类&lt;/h1&gt;
&lt;h2&gt;纯虚函数&lt;/h2&gt;
&lt;p&gt;纯虚函数是一种特殊的虚函数，它没有具体的实现，仅在基类中声明。纯虚函数的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0; // 纯虚函数
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;纯虚函数的定义表示该函数必须在派生类中被实现。如果派生类没有实现纯虚函数，则该派生类也是抽象类。&lt;/p&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;p&gt;包含纯虚函数的类称为抽象类。抽象类不能被实例化，只能作为基类被派生。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    // Base b; // 错误！抽象类不能被实例化
    Derived d;
    d.print(); // 输出 Derived::print()
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;纯虚函数的实现&lt;/h2&gt;
&lt;p&gt;虽然纯虚函数没有默认实现，但可以在基类中提供一个默认实现。派生类可以选择性地覆盖该实现。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() = 0 {
        cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl;
    }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;虚表（Virtual Table）的实现&lt;/h1&gt;
&lt;p&gt;虚表是 C++ 编译器为每个包含虚函数的类生成的一个隐藏的数据结构。虚表是一个函数指针数组，存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;h2&gt;虚表的结构&lt;/h2&gt;
&lt;p&gt;假设我们有以下类定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void f1() { cout &amp;lt;&amp;lt; &quot;Base::f1&quot; &amp;lt;&amp;lt; endl; }
    virtual void f2() { cout &amp;lt;&amp;lt; &quot;Base::f2&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void f1() override { cout &amp;lt;&amp;lt; &quot;Derived::f1&quot; &amp;lt;&amp;lt; endl; }
    void f2() override { cout &amp;lt;&amp;lt; &quot;Derived::f2&quot; &amp;lt;&amp;lt; endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器会为 &lt;code&gt;Base&lt;/code&gt; 和 &lt;code&gt;Derived&lt;/code&gt; 类生成虚表，其结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Base 类的虚表&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Base::f1&lt;/code&gt; 的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Base::f2&lt;/code&gt; 的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Derived 类的虚表&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Derived::f1&lt;/code&gt; 的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Derived::f2&lt;/code&gt; 的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;虚表的内存布局&lt;/h2&gt;
&lt;p&gt;假设 &lt;code&gt;Base&lt;/code&gt; 和 &lt;code&gt;Derived&lt;/code&gt; 类的对象在内存中的布局如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Base 对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vptr（指向 Base 的虚表）&lt;/li&gt;
&lt;li&gt;其他成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Derived 对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vptr（指向 Derived 的虚表）&lt;/li&gt;
&lt;li&gt;其他成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当通过基类指针调用虚函数时，程序通过 vptr 查找虚表，找到对应的函数地址并调用。这种机制确保了多态的实现。&lt;/p&gt;
&lt;h2&gt;虚表的初始化&lt;/h2&gt;
&lt;p&gt;当对象被创建时，构造函数会初始化对象的 vptr，使其指向正确的虚表。如果对象是派生类的实例，vptr 会被初始化为指向派生类的虚表。&lt;/p&gt;
&lt;h2&gt;虚表的继承&lt;/h2&gt;
&lt;p&gt;当派生类继承自基类时，派生类会继承基类的虚表。如果派生类重写了基类的虚函数，虚表中的相应条目会被更新为派生类的函数地址。如果派生类没有重写某些虚函数，虚表中的条目则保持基类的函数地址。&lt;/p&gt;
&lt;h2&gt;虚表的大小&lt;/h2&gt;
&lt;p&gt;虚表的大小取决于类中虚函数的数量。每个虚函数占用一个指针大小的空间（通常是 4 或 8 字节，取决于平台）。&lt;/p&gt;
&lt;h2&gt;虚表的性能开销&lt;/h2&gt;
&lt;p&gt;虽然虚表引入了一定的性能开销（主要是通过 vptr 查找虚表的额外操作），但这种开销通常是可以接受的。虚表的查找时间是常数时间 (O(1))，因此虚函数的调用效率仍然很高。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;虚函数的高级用法&lt;/h1&gt;
&lt;h2&gt;虚析构函数&lt;/h2&gt;
&lt;p&gt;虚析构函数是虚函数的一个重要应用。当通过基类指针删除派生类对象时，需要确保调用派生类的析构函数。通过将析构函数声明为虚函数，可以实现这一点。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual ~Base() { cout &amp;lt;&amp;lt; &quot;Base destructor&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    ~Derived() { cout &amp;lt;&amp;lt; &quot;Derived destructor&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr; // 输出 Derived destructor 和 Base destructor
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚函数与模板&lt;/h2&gt;
&lt;p&gt;虚函数和模板可以结合使用，但需要注意模板函数不能是虚函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base {
public:
    virtual void print() { cout &amp;lt;&amp;lt; &quot;Base::print()&quot; &amp;lt;&amp;lt; endl; }
};

class Derived : public Base {
public:
    void print() override { cout &amp;lt;&amp;lt; &quot;Derived::print()&quot; &amp;lt;&amp;lt; endl; }
};

template &amp;lt;typename T&amp;gt;
void print(T* obj) {
    obj-&amp;gt;print();
}

int main() {
    Base* ptr = new Derived();
    print(ptr); // 输出 Derived::print()
    delete ptr;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;虚函数是 C++ 中实现多态的核心机制。通过虚函数，派生类可以重写基类的函数实现，从而实现动态绑定。虚函数的设计理念源自于“重载函数”，但它们的目标和实现方式有所不同。虚函数的实现依赖于虚表（vtable）和虚指针（vptr）。&lt;/p&gt;
&lt;p&gt;纯虚函数和抽象类是虚函数的高级应用，它们允许我们定义接口类，确保派生类实现特定的函数。虚表是虚函数实现的基础，它存储了类中所有虚函数的地址。每个对象都有一个指向其类虚表的指针（vptr），通过 vptr 可以访问虚表。&lt;/p&gt;
&lt;p&gt;理解虚函数和虚表的工作原理，有助于我们更好地掌握 C++ 的对象模型和性能优化。&lt;/p&gt;
</content:encoded></item><item><title>CMake：自动化构建的利器</title><link>https://loners.site/posts/cmake/</link><guid isPermaLink="true">https://loners.site/posts/cmake/</guid><description>`Makefile`跟系统的编译有很重要的相关，在不同的系统上`Makefile`编译出来的文件是不相同的，这时候对于我们跨平台解决问题有一个致命问题，好在我们有`CMake`来解决这一难题。</description><pubDate>Sat, 23 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;在现代软件开发中，构建系统是不可或缺的一部分。CMake 作为一种跨平台的自动化构建系统生成器，极大地简化了项目的编译和构建过程。与 Makefile 类似，CMake 通过编写配置文件（CMakeLists.txt）来定义项目的构建规则，但它的优势在于更高的可移植性和更强大的功能。CMake 可以生成多种构建系统，如 Makefile、Visual Studio 解决方案等，从而满足不同开发环境的需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
本课程笔记源自 &lt;a href=&quot;https://cmake.org/documentation/&quot;&gt;CMake 官方文档&lt;/a&gt; 和 &lt;a href=&quot;https://www.bilibili.com/video/BV1bg411p7oS/?&quot;&gt;CMake 教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CMake 涉及到 C++ 的多文件编译与运行，以下是一个简单的示例项目结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;project/
├── CMakeLists.txt
├── main.cpp
├── factorial.cpp
├── printhello.cpp
└── functions.h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中代码内容如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
using namespace std;

int main() {
    printhello();
    cout &amp;lt;&amp;lt; &quot;This is main:&quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;The factorial of 5 is: &quot; &amp;lt;&amp;lt; factorial(5) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;factorial.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;functions.h&quot;

int factorial(int n) {
    if (n == 1)
        return 1;
    else
        return n * factorial(n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printhello.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;

using namespace std;

void printhello() {
    cout &amp;lt;&amp;lt; &quot;Hello world&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;functions.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_

void printhello();
int factorial(int n);

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;法一（不使用 CMake）：&lt;/h1&gt;
&lt;p&gt;直接使用 &lt;code&gt;g++&lt;/code&gt; 编译项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
g++ main.cpp factorial.cpp printhello.cpp -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者手动编译每个源文件并链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.cpp -c
g++ factorial.cpp -c
g++ printhello.cpp -c
g++ *.o -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;法二（使用 CMake）：&lt;/h1&gt;
&lt;h2&gt;version1&lt;/h2&gt;
&lt;p&gt;创建一个简单的 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 1
# 设置 CMake 的最低版本要求
cmake_minimum_required(VERSION 3.0)

# 设置项目名称
project(MyProject)

# 添加可执行文件
add_executable(hello main.cpp printhello.cpp factorial.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 CMake：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
mkdir build
cd build
cmake ..
make
./hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version2&lt;/h2&gt;
&lt;p&gt;更灵活的 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 2
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤与 version1 相同。&lt;/p&gt;
&lt;h2&gt;version3&lt;/h2&gt;
&lt;p&gt;使用变量和更复杂的构建规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 3
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})

# 添加自定义目标
add_custom_target(run_hello COMMAND ./hello)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd project
mkdir build
cd build
cmake ..
make run_hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version4&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;target_include_directories&lt;/code&gt; 和 &lt;code&gt;target_link_libraries&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 4
cmake_minimum_required(VERSION 3.0)
project(MyProject)

# 设置 C++ 编译器选项
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -std=c++11&quot;)

# 添加源文件
set(SOURCE_FILES main.cpp printhello.cpp factorial.cpp)

# 添加可执行文件
add_executable(hello ${SOURCE_FILES})

# 添加头文件目录
target_include_directories(hello PRIVATE ${CMAKE_SOURCE_DIR})

# 添加链接库（如果有）
# target_link_libraries(hello &amp;lt;library_name&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行步骤与前面版本相同。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;CMake 提供了一种高效且灵活的方式来管理项目的构建过程。与手动编写 Makefile 或直接使用编译器命令相比，CMake 的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;：CMake 可以生成适用于不同操作系统的构建文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于维护&lt;/strong&gt;：通过 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件，可以清晰地定义项目的构建规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的功能&lt;/strong&gt;：支持复杂的项目结构、依赖管理和自定义目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实际项目中，使用 CMake 可以显著提高开发效率，减少重复劳动，并确保构建过程的一致性。&lt;/p&gt;
</content:encoded></item><item><title>Lambda 表达式与函数对象概述</title><link>https://loners.site/posts/cpp-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><guid isPermaLink="true">https://loners.site/posts/cpp-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>Lambda 表达式和函数对象是 C++11 引入的非常强大的特性，它们极大地简化了函数的定义和使用方式。就像一把多功能瑞士军刀，有了它们，我们可以在代码中更灵活地处理函数逻辑，无论是简单的回调函数，还是复杂的算法实现，都可以轻松应对。</description><pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Lambda 表达式和函数对象是 C++11 引入的非常强大的特性，它们极大地简化了函数的定义和使用方式。就像一把多功能瑞士军刀，有了它们，我们可以在代码中更灵活地处理函数逻辑，无论是简单的回调函数，还是复杂的算法实现，都可以轻松应对。接下来，让我们深入了解一下 Lambda 表达式和函数对象的奥秘。&lt;/p&gt;
&lt;h1&gt;Lambda 表达式(Lambda Expressions)&lt;/h1&gt;
&lt;p&gt;Lambda 表达式是一种匿名函数，它允许我们在代码中直接定义函数逻辑，而无需单独声明一个函数。Lambda 表达式的核心是对函数对象的封装，它提供了一种简洁的方式来实现函数式编程。&lt;/p&gt;
&lt;h2&gt;Lambda 表达式的语法&lt;/h2&gt;
&lt;p&gt;Lambda 表达式的基本语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[capture_list](parameters) -&amp;gt; return_type { body }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capture_list&lt;/strong&gt;：捕获列表，用于捕获外部变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parameters&lt;/strong&gt;：参数列表，与普通函数类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;return_type&lt;/strong&gt;：返回类型，可以省略，由编译器推导。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;body&lt;/strong&gt;：函数体，包含具体的逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lambda 表达式的使用&lt;/h2&gt;
&lt;p&gt;Lambda 表达式可以用于任何需要函数对象的场景，例如作为算法的参数、实现回调函数等。以下是一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};

    // 使用 Lambda 表达式作为回调函数
    std::for_each(v.begin(), v.end(), [](int x) {
        std::cout &amp;lt;&amp;lt; x * x &amp;lt;&amp;lt; &quot; &quot;;
    });

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Lambda 表达式的捕获机制&lt;/h2&gt;
&lt;p&gt;Lambda 表达式可以通过捕获列表捕获外部变量，捕获方式分为值捕获和引用捕获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;值捕获&lt;/strong&gt;：通过值捕获外部变量，捕获的变量在 Lambda 表达式中是副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用捕获&lt;/strong&gt;：通过引用捕获外部变量，捕获的变量在 Lambda 表达式中是引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int main() {
    int a = 10;
    int b = 20;

    // 值捕获
    auto lambda1 = [a, b]() {
        std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl; // 输出 30
    };

    // 引用捕获
    auto lambda2 = [&amp;amp;a, &amp;amp;b]() {
        std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl; // 输出 30
        a = 100; // 修改 a 的值
    };

    lambda1();
    lambda2();
    std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; // 输出 100

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;函数对象(Function Objects)&lt;/h1&gt;
&lt;p&gt;函数对象是一种重载了函数调用运算符&lt;code&gt;()&lt;/code&gt;的对象，它可以像函数一样被调用。函数对象比普通函数更灵活，因为它可以包含状态信息。&lt;/p&gt;
&lt;h2&gt;函数对象的定义&lt;/h2&gt;
&lt;p&gt;函数对象可以通过定义一个类并重载&lt;code&gt;()&lt;/code&gt;运算符来实现。以下是一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Adder {
public:
    Adder(int num) : num_(num) {} // 构造函数初始化状态

    int operator()(int x) const {
        return x + num_;
    }

private:
    int num_;
};

int main() {
    Adder add5(5);
    std::cout &amp;lt;&amp;lt; add5(10) &amp;lt;&amp;lt; std::endl; // 输出 15
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;函数对象的使用&lt;/h2&gt;
&lt;p&gt;函数对象可以用于需要函数指针或回调函数的场景。与 Lambda 表达式类似，函数对象也可以包含状态信息，因此在某些场景下比 Lambda 表达式更灵活。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};

    // 定义一个函数对象
    struct Square {
        void operator()(int x) const {
            std::cout &amp;lt;&amp;lt; x * x &amp;lt;&amp;lt; &quot; &quot;;
        }
    };

    // 使用函数对象作为回调函数
    std::for_each(v.begin(), v.end(), Square());

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Lambda 表达式与函数对象的比较&lt;/h1&gt;
&lt;p&gt;Lambda 表达式和函数对象都可以用于实现函数式编程，但它们有一些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;更简洁，适合快速定义简单的函数逻辑。&lt;/li&gt;
&lt;li&gt;语法灵活，支持捕获外部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数对象&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;更灵活，可以包含状态信息。&lt;/li&gt;
&lt;li&gt;可以通过类的成员函数实现更复杂的逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际使用中，可以根据具体需求选择合适的工具。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了一种简洁的方式来定义匿名函数。&lt;/li&gt;
&lt;li&gt;支持捕获外部变量，语法灵活。&lt;/li&gt;
&lt;li&gt;适用于简单的函数逻辑和回调函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重载&lt;code&gt;()&lt;/code&gt;运算符实现，可以包含状态信息。&lt;/li&gt;
&lt;li&gt;更灵活，适用于复杂的逻辑和需要状态的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择工具&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据具体需求选择 Lambda 表达式或函数对象。&lt;/li&gt;
&lt;li&gt;灵活运用它们可以提高代码的可读性和可维护性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>Makefile</title><link>https://loners.site/posts/makefile/</link><guid isPermaLink="true">https://loners.site/posts/makefile/</guid><description>Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个Make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，Makefile都成为了一种在工程方面的编译方法。</description><pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个Make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，Makefile都成为了一种在工程方面的编译方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
本课程笔记源自&lt;a href=&quot;https://www.bilibili.com/video/BV188411L7d2&quot;&gt;Makefile&lt;/a&gt;,以及&lt;a href=&quot;https://www.bilibili.com/video/BV1bg411p7oS/?&quot;&gt;CMake&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Makefile涉及到cpp的多文件同时编译与运行，我们在编译一下代码的时候会涉及到：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
using namespace std;
 
int main()
{
    printhello();
    cout &amp;lt;&amp;lt; &quot;This is main:&quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;The factorial of 5 is: &quot; &amp;lt;&amp;lt; factorial(5) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;factorial.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;functions.h&quot;
 
int factorial(int n)
{
    if(n == 1)
            return 1;
    else
            return n * factorial(n-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printhello.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;functions.h&quot;
 
using namespace std;
 
void printhello()
{
    int i;
    cout &amp;lt;&amp;lt; &quot;Hello world&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;function.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_
void printhello();
int factorial(int n);
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;法一(不使用makefile)：&lt;/h1&gt;
&lt;p&gt;进入learn_makefile生成可执行程序文件&lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd learn_makefile
g++ main.cpp factorial.cpp printhello.cpp -o main
./main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;逐个&lt;strong&gt;编译&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ main.cpp -c
g++ factorial.cpp -c
g++ helloprint.cpp -c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再进行&lt;strong&gt;链接&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ *.o -o main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再用&lt;code&gt;g++&lt;/code&gt;来运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;一般我们用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm *.o
rm main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除&lt;code&gt;.o&lt;/code&gt;文件和&lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;法二(创建Makefile文件):&lt;/h1&gt;
&lt;h2&gt;verison1&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 1
# hello为生成的可执行文件，依赖于后面的三个.cpp文件
# g++前面加一个TAB的空格
hello: main.cpp printhello.cpp factorial.cpp
	g++ -o hello main.cpp printhello.cpp factorial.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cd learn_makefile
make
./hellop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点:文件多时，编译时间长&lt;/p&gt;
&lt;h2&gt;version2&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;文件有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 2
CXX = g++
TARGET = hello
OBJ = main.o printhello.o factorial.o
# make时执行g++ 先找TARGET，TARGET不存在找OBJ，OBJ不存在，编译三个.cpp文件生成.o文件
# 然后再编译OBJ文件，生成可执行文件hello
$(TARGET): $(OBJ)
	$(CXX) -o $(TARGET) $(OBJ)
# main.o这样来的，编译main.cpp生成
main.o: main.cpp
	$(CXX) -c main.cpp
printhello.o: printhello.cpp
	$(CXX) -c printhello.cpp
factorial.o: factorial.cpp
	$(CXX) -c factorial.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version3&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 3
CXX = g++
TARGET = hello
OBJ = main.o printhello.o factorial.o
 
# 编译选项，显示所有的warning
CXXLAGS = -c -Wall
 
# $@表示的就是冒号前面的TARGET，$^表示的是冒号后OBJ的全部.o依赖文件
$(TARGET): $(OBJ)
	$(CXX) -o $@ $^
 
# $&amp;lt;表示指向%.cpp依赖的第一个，但是这里依赖只有一个
# $@表示指向%.o
%.o: %.cpp
	$(CXX) $(CXXLAGS) $&amp;lt; -o $@
 
# 为了防止文件夹中存在一个文件叫clean
.PHONY: clean
 
# -f表示强制删除，此处表示删除所有的.o文件和TARGET文件
clean:
	rm -f *.o $(TARGET)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;version4&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# VERSION 4
CXX = g++
TARGET = hello
# 所有当前目录的.cpp文件都放在SRC里面
SRC = $(wildcard *.cpp)
# 把SRC里面的.cpp文件替换为.o文件
OBJ = $(patsubst %.cpp, %.o,$(SRC))
 
CXXLAGS = -c -Wall
 
$(TARGET): $(OBJ)
	$(CXX) -o $@ $^
 
%.o: %.cpp
	$(CXX) $(CXXLAGS) $&amp;lt; -o $@
 
.PHONY: clean
clean:
	rm -f *.o $(TARGET)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;写项目的时候我们如果采用&lt;code&gt;Makefile&lt;/code&gt;方法，我们的脚本仅仅需要写一次，而用gcc命令的话，我们每次都需要重新写一遍。&lt;/p&gt;
</content:encoded></item><item><title>重载函数</title><link>https://loners.site/posts/cpp-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://loners.site/posts/cpp-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</guid><description>`Cpp` 的重载函数是依据于 `Argument-dependent lookup`（也称作 ADL），也就是说，即使有相同的函数名，但是我们也依据参数列表的不同来调用，这涉及到编译原理。我们知道，利用 `.cpp` 文件可以编译成 `.obj` 文件，再通过链接器链接变成 `.exe` 文件，而 `Cpp` 的重载特性就是从编译器下手的。</description><pubDate>Thu, 21 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;我们为什么要重载？搞清楚这个问题我们要回顾到 &lt;code&gt;C&lt;/code&gt; 中，&lt;code&gt;C99&lt;/code&gt; 中有一个 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 头文件，里面定义了不同的四舍五入方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;roundf&lt;/td&gt;
&lt;td&gt;(float x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;roundl&lt;/td&gt;
&lt;td&gt;(long double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们发现不同的数据类型有不同的函数名，而其效果都是达到一个四舍五入的效果，但是，这种函数名加重了我们的记忆负担，不利于我们去记忆。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cpp&lt;/code&gt; 提供了一个函数重载的功能，这个功能可以方便我们记忆函数。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;C++11&lt;/code&gt; 的 &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; 为例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(float x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;round&lt;/td&gt;
&lt;td&gt;(long double x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;重载函数如何实现？&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Cpp&lt;/code&gt; 的重载函数是依据于 &lt;code&gt;Argument-dependent lookup&lt;/code&gt;（也称作 ADL），也就是说，即使有相同的函数名，但是我们也依据参数列表的不同来调用，这涉及到编译原理。我们知道，利用 &lt;code&gt;.cpp&lt;/code&gt; 文件可以编译成 &lt;code&gt;.obj&lt;/code&gt; 文件，再通过链接器链接变成 &lt;code&gt;.exe&lt;/code&gt; 文件，而 &lt;code&gt;Cpp&lt;/code&gt; 的重载特性就是从编译器下手的。&lt;/p&gt;
&lt;p&gt;我们可以自定义多个 &lt;code&gt;max()&lt;/code&gt; 函数，通过打印来确定我们采用的是哪一个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int max(int x, int y) {
    cout &amp;lt;&amp;lt; &quot;max(int,int) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

float max(float x, float y) {
    cout &amp;lt;&amp;lt; &quot;max(float,float) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

double max(double x, double y) {
    cout &amp;lt;&amp;lt; &quot;max(double,double) is called&quot; &amp;lt;&amp;lt; endl;
    return x &amp;gt; y ? x : y;
}

int main() {
    cout &amp;lt;&amp;lt; max(3, 5) &amp;lt;&amp;lt; endl;       // 调用 int 版本
    cout &amp;lt;&amp;lt; max(3.5f, 5.2f) &amp;lt;&amp;lt; endl; // 调用 float 版本
    cout &amp;lt;&amp;lt; max(3.5, 5.2) &amp;lt;&amp;lt; endl;   // 调用 double 版本
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;防止歧义&lt;/h1&gt;
&lt;p&gt;在使用重载函数时，需要注意防止歧义。如果编译器无法根据参数类型唯一确定调用的函数版本，就会导致编译错误。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x) {
    cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl;
}

void print(double x) {
    cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl;
}

int main() {
    print(5);    // 明确调用 print(int)
    print(5.0);  // 明确调用 print(double)
    print(5.0f); // 错误！无法确定是调用 print(int) 还是 print(double)
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了避免歧义，需要确保重载函数的参数类型之间有足够的区分度，或者通过显式类型转换来明确指定调用的版本。&lt;/p&gt;
&lt;h1&gt;重载的规则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数数量不同&lt;/strong&gt;：可以通过参数数量的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print() { cout &amp;lt;&amp;lt; &quot;No arguments&quot; &amp;lt;&amp;lt; endl; }
void print(int x) { cout &amp;lt;&amp;lt; &quot;One int argument&quot; &amp;lt;&amp;lt; endl; }
void print(int x, int y) { cout &amp;lt;&amp;lt; &quot;Two int arguments&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数类型不同&lt;/strong&gt;：可以通过参数类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(double x) { cout &amp;lt;&amp;lt; &quot;print(double)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数类型顺序不同&lt;/strong&gt;：可以通过参数类型的顺序不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x, double y) { cout &amp;lt;&amp;lt; &quot;print(int, double)&quot; &amp;lt;&amp;lt; endl; }
void print(double x, int y) { cout &amp;lt;&amp;lt; &quot;print(double, int)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用类型不同&lt;/strong&gt;：可以通过引用类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int &amp;amp;x) { cout &amp;lt;&amp;lt; &quot;print(int &amp;amp;)&quot; &amp;lt;&amp;lt; endl; }
void print(const int &amp;amp;x) { cout &amp;lt;&amp;lt; &quot;print(const int &amp;amp;)&quot; &amp;lt;&amp;lt; endl; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;重载的限制&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回值类型不能用于重载&lt;/strong&gt;：不能仅通过返回值类型的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int add(int x, int y) { return x + y; }
double add(int x, int y) { return x + y; } // 错误！无法通过返回值类型重载
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数默认值不能用于重载&lt;/strong&gt;：不能仅通过参数默认值的不同来重载函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void print(int x = 0) { cout &amp;lt;&amp;lt; &quot;print(int)&quot; &amp;lt;&amp;lt; endl; }
void print(int x = 0, int y = 0) { cout &amp;lt;&amp;lt; &quot;print(int, int)&quot; &amp;lt;&amp;lt; endl; } // 错误！无法通过默认值重载
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;构造函数重载&lt;/h1&gt;
&lt;p&gt;构造函数也可以重载，通过不同的参数列表来实现对象的初始化。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Point {
public:
    Point() : x(0), y(0) { cout &amp;lt;&amp;lt; &quot;Default constructor&quot; &amp;lt;&amp;lt; endl; }
    Point(int x, int y) : x(x), y(y) { cout &amp;lt;&amp;lt; &quot;Constructor with two ints&quot; &amp;lt;&amp;lt; endl; }
    Point(double x, double y) : x(x), y(y) { cout &amp;lt;&amp;lt; &quot;Constructor with two doubles&quot; &amp;lt;&amp;lt; endl; }

private:
    int x, y;
};

int main() {
    Point p1;                 // 调用默认构造函数
    Point p2(3, 4);           // 调用 int 版本构造函数
    Point p3(3.5, 4.2);       // 调用 double 版本构造函数
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;重载与模板&lt;/h1&gt;
&lt;p&gt;模板函数也可以参与重载。模板函数的实例化是根据模板参数的类型来确定的，因此模板函数可以与普通函数或模板函数重载。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;typename T&amp;gt;
void print(T x) {
    cout &amp;lt;&amp;lt; &quot;Template print(T)&quot; &amp;lt;&amp;lt; endl;
}

void print(int x) {
    cout &amp;lt;&amp;lt; &quot;Non-template print(int)&quot; &amp;lt;&amp;lt; endl;
}

int main() {
    print(5);    // 调用非模板版本
    print(5.0);  // 调用模板版本
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;函数重载是 C++ 提供的一种强大的功能，它允许我们使用相同的函数名来实现不同的功能。通过参数数量、参数类型、参数顺序等的不同，可以实现函数的重载。在使用重载函数时，需要注意避免歧义，并遵循重载的规则。合理使用重载可以提高代码的可读性和可维护性。&lt;/p&gt;
</content:encoded></item></channel></rss>